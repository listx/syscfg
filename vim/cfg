set number "line numbers
set nobackup
" default tabstop and shiftwidths
set tabstop=4
set shiftwidth=4
set expandtab

" see ":help statusline" for more information about status lines, as well as
" the default "standard" one
"
" %{&ff} gives the file format, but is not used here because it is hardly ever
" needed
set statusline=%<%F\ %h%m%r%=%-14.(%l,%c%V%)\ %P\ %L
syntax enable "enable syntax highlighting
set hlsearch "turn on search highlighting
filetype indent on "turn on automatic indenting, as well as filetype recognition

set guioptions-=T  "remove toolbar
set guioptions-=m  "remove menu
set guioptions-=r  "remove scrollbar
set lbr "for word wrapping to be based on words, not characters
set gfn=Terminus\ 11
" so zenburn's background is properly loaded ... 2008/12/23
set t_Co=256
if has('gui_running')
    colorscheme delek
else
    colorscheme zenburn_mod
endif

" Turn off blinking for the n, v, & c states:
"let &guicursor = substitute(&guicursor, "n-v-c:", "n-v-c:blinkon0-", "")
" NOTE: To stop all blinking:
" let &guicursor = &guicursor . ",a:blinkon0"
set guicursor+=a:block-blinkon0 "make cursor look square, and prevent cursor blinking

" Yuri Klubakov's sessionman.vim script: disable automatic session saves
" on exit
let sessionman_save_on_exit = 0

" Set maximum number of tabs on startup to 50, instead of the default 10
"
" If you exceed the number of tabs allowed by tabpagemax Vim will simply open the maximum number of tabs, and the other files will be open but not displayed. You can edit the remaining files by using the :next or :last command to move to the files that are not displayed in a tab. Note that this setting only applies to the maximum number of tabs Vim will open on startup -- you can still open more tabs during your Vim session.
set tabpagemax=50

" wait 10 seconds instead of 0.5 seconds before erasing any "half-finished"
" commands in normal/visual mode
set timeoutlen=10000

" change the default universal default mod-key for custom key mappings from
" backslash "\" to ","
let mapleader = ","

" we only want to load autocommands ONCE (esp. for gvim, which sources the
" vimrc
if !exists("autocommands_loaded")
    let autocommands_loaded = 1
    " custom configobj (python module) syntax highlighting
    au BufRead,BufNewFile *.configobj set filetype=configobj
    au! Syntax configobj source $HOME/.vim/syntax/configobj.vim
    au BufRead,BufNewFile *.lhp set filetype=lhp
    au! Syntax lhp source $HOME/.vim/syntax/lhp.vim

    " tabstop is how wide the <TAB> character is, whether it's an actual <TAB>
    " character or converted into space characters with expandtab
    au BufRead,BufNewFile *.rb,*.py set tabstop=4
    " shiftwidth is how many characters are used when auto-indenting, and also
    " when typing '>>' and '<<' in normal mode
    au BufRead,BufNewFile *.rb,*.py set shiftwidth=4
" Note that vim's 'textwidth' only really works for COMMENT lines, as doing so otherwise would break whitespace-sensitive code (like Python)
    au BufRead,BufNewFile *.rb,*.py set textwidth=120
    au BufRead,BufNewFile *.c,*.cpp,*.h,*.hpp set tabstop=8
    au BufRead,BufNewFile *.c,*.cpp,*.h,*.hpp set shiftwidth=8
    au BufRead,BufNewFile *.c,*.cpp,*.h,*.hpp set textwidth=120
    au BufRead .vimperatorrc set syn=vim " use vim script syntax highlighting
    " load lilypond-specific stuff
    au BufRead,BufNewFile *.ly set filetype=lilypond
    au! Syntax lilypond source $HOME/.vim/syntax/lilypond.vim
    "au! Syntax lilypond source /usr/share/lilypond/2.12.2/vim/syntax/lilypond.vim

    " Integration with the "boxes" program by Thomas Jensen.
    " Default width is set at 100 characters
    au BufEnter * nmap <leader>c1 !!boxes -d pound-alt<CR>
    au BufEnter * vmap <leader>c1 !boxes -d pound-alt<CR>
    au BufEnter * nmap <leader>cw1 !!boxes -d pound-alt -s 120<CR>
    au BufEnter * vmap <leader>cw1 !boxes -d pound-alt -s 120<CR>
    au BufEnter * nmap <leader>x1 !!boxes -d pound-alt -r<CR>
    au BufEnter * vmap <leader>x1 !boxes -d pound-alt -r<CR> 
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <leader>c1 !!boxes -d c-top<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <leader>c1 !boxes -d c-top<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <leader>cw1 !!boxes -d c-top -s 120<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <leader>cw1 !boxes -d c-top -s 120<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <leader>x1 !!boxes -d c-top -r<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <leader>x1 !boxes -d c-top -r<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <leader>c2 !!boxes -d c-mid<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <leader>c2 !boxes -d c-mid<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <leader>cw2 !!boxes -d c-mid -s 120<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <leader>cw2 !boxes -d c-mid -s 120<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <leader>x2 !!boxes -d c-mid -r<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <leader>x2 !boxes -d c-mid -r<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <leader>c3 !!boxes -d c-bot<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <leader>c3 !boxes -d c-bot<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <leader>cw3 !!boxes -d c-bot -s 120<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <leader>cw3 !boxes -d c-bot -s 120<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <leader>x3 !!boxes -d c-bot -r<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <leader>x3 !boxes -d c-bot -r<CR>
    au BufEnter .vimrc,.gvimrc,.vimperatorrc nmap <leader>c1 !!boxes -d vim-cmt<CR>
    au BufEnter .vimrc,.gvimrc,.vimperatorrc vmap <leader>c1 !boxes -d vim-cmt<CR>
    au BufEnter .vimrc,.gvimrc,.vimperatorrc nmap <leader>cw1 !!boxes -d vim-cmt -s 120<CR>
    au BufEnter .vimrc,.gvimrc,.vimperatorrc vmap <leader>cw1 !boxes -d vim-cmt -s 120<CR>
    au BufEnter .vimrc,.gvimrc,.vimperatorrc nmap <leader>x1 !!boxes -d vim-cmt -r<CR>
    au BufEnter .vimrc,.gvimrc,.vimperatorrc vmap <leader>x1 !boxes -d vim-cmt -r<CR>
    au BufEnter *.ly nmap <leader>c1 !!boxes -d percent<CR>
    au BufEnter *.ly vmap <leader>c1 !boxes -d percent<CR>
    au BufEnter *.ly nmap <leader>cw1 !!boxes -d percent -s 120<CR>
    au BufEnter *.ly vmap <leader>cw1 !boxes -d percent -s 120<CR>
    au BufEnter *.ly nmap <leader>x1 !!boxes -d percent -r<CR>
    au BufEnter *.ly vmap <leader>x1 !boxes -d percent -r<CR>

    " useful for selecting multi-word phrases; you can select either
    " right-to-left or left-to-right -- just highlight a portion of the two
    " leftmost and rightmost words in the phrase
    au BufEnter *.lhp vmap <leader>bb iwoiw"zdib[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <leader>ii iwoiw"zdii[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <leader>u  iwoiw"zdiu[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <leader>bi iwoiw"zdibi[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <leader>bu iwoiw"zdibu[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <leader>iu iwoiw"zdiiu[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <leader>cc iwoiw"zdic[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <leader>cp iwoiw"zdicp[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <leader>sc iwoiw"zdisc[[<C-R>z]]<Esc>
    " useful for manually selecting the exact boundaries
    au BufEnter *.lhp vmap <leader>mbb "zdib[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <leader>mii "zdii[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <leader>mu  "zdiu[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <leader>mbi "zdibi[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <leader>mbu "zdibu[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <leader>miu "zdiiu[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <leader>mcc "zdic[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <leader>mcp "zdicp[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <leader>msc "zdisc[[<C-R>z]]<Esc>
    " useful for highlighting a single word from normal mode (just hover a
    " cursor over the single word you want to tag)
    au BufEnter *.lhp nmap <leader>bb viw"zdib[[<C-R>z]]<Esc>
    au BufEnter *.lhp nmap <leader>ii viw"zdii[[<C-R>z]]<Esc>
    au BufEnter *.lhp nmap <leader>u  viw"zdiu[[<C-R>z]]<Esc>
    au BufEnter *.lhp nmap <leader>bi viw"zdibi[[<C-R>z]]<Esc>
    au BufEnter *.lhp nmap <leader>bu viw"zdibu[[<C-R>z]]<Esc>
    au BufEnter *.lhp nmap <leader>iu viw"zdiiu[[<C-R>z]]<Esc>
    au BufEnter *.lhp nmap <leader>cc viw"zdic[[<C-R>z]]<Esc>
    au BufEnter *.lhp nmap <leader>cp viw"zdicp[[<C-R>z]]<Esc>
    au BufEnter *.lhp nmap <leader>sc viw"zdisc[[<C-R>z]]<Esc>
    function Insert_newline_smartly()
        if col(".") != 1
            normal o
        endif
    endfunction
    function Toggle_status_bar()
        if &laststatus < 2
            let &laststatus = 2
        else
            let &laststatus = 1 " set it back to Vim's default
        endif
    endfunction
endif

" quickly enter current date and time
" NOTE: the <F1> key in normal mode is mapped to ":help" by default
map <silent> <F1> :call Insert_newline_smartly()<CR>i<C-R>=strftime("%F (%a) %T")<Esc><Space>-><Space>
imap <silent> <F1> <Esc>:call Insert_newline_smartly()<CR>i<C-R>=strftime("%F (%a) %T")<Esc><Space>-><Space>

" exit
map <F2> :q<CR>
imap <F2> <Esc>:q<CR>

" turn off search highlighting (to turn on, press 'n' in normal mode for next
" term)
map <F3> :noh<CR>
imap <F3> <Esc>:noh<CR>a

" quicksave files
map <F4> :w<CR>
imap <F4> <Esc>:w<CR>a

" programming commands
imap <F5> <Esc>:!g++ -Wall -mtune=native -m32 % -o ~/prog/temp32<CR>
imap <F6> <Esc>:!xterm -hold -e ~/prog/temp32<CR>
map <F6> <Esc>:!xterm -hold -e ~/prog/temp32<CR>

" make windows equal in height/width
nmap <F10> <C-w>=
imap <F10> <C-w>=

" toggle status bar
map <silent> <F11> :call Toggle_status_bar()<CR>
imap <silent> <F11> <Esc>:call Toggle_status_bar()<CR>

" toggle line numbers
map <F12> :set number!<CR>
imap <F12> <Esc>:set number!<CR>

" makes j and k move up or down 1 "line" as it appears on the screen -- not by
" the actual number of lines in the text file
nnoremap k gk
nnoremap j gj

" integration with the sessionman.vim plugin by Yuri Klubakov
nmap <leader>so :SessionOpen<space>
nmap <leader>ss :SessionSave<CR>
nmap <leader>sa :SessionSaveAs<space>

" tab movement
nnoremap <C-l> :tabnext<CR>
nnoremap <C-h> :tabprevious<CR>
inoremap <C-l> <Esc>:tabnext<CR>
inoremap <C-h> <Esc>:tabprevious<CR>

" window movement (i.e., moving around INSIDE a tab)
nmap <C-j> <C-w>j
nmap <C-k> <C-w>k
imap <C-j> <Esc><C-w>j
imap <C-k> <Esc><C-w>k

" buffer movement (i.e., moving around INSIDE a window)
nmap <S-h> :bn<CR>
nmap <S-l> :bp<CR>
