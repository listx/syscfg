set ffs=unix "always interpret all files as if they are unix files
set number "line numbers
set nobackup
" default tabstop and shiftwidths
set tabstop=4
set shiftwidth=4
set expandtab

" see ":help statusline" for more information about status lines, as well as
" the default "standard" one
"
" %{&ff} gives the file format, but is not used here because it is hardly ever
" needed
set statusline=%<%F\ %h%m%r%=%-14.(%l,%c%V%)\ %P\ %L
set laststatus=2
syntax enable "enable syntax highlighting
set hlsearch "turn on search highlighting
filetype indent on "turn on automatic indenting based on filetype recognition
filetype plugin on "automatically load the corresponding filetype plugin if we've detected a filetype

" Tip: to search case-insensitive, type \c at the beginning

set incsearch " search any match IMMEDIATELY

set mousehide " hide the mouse cursor when typing (only for GVIM)

set guioptions-=T  "remove toolbar
set guioptions-=m  "remove menu
set guioptions-=r  "remove scrollbar
set lbr "for word wrapping to be based on words, not characters
set gfn=Terminus\ 11
" so zenburn's background is properly loaded ... 2008/12/23
set t_Co=256

colorscheme zenburn_mod2

" Turn off blinking for the n, v, & c states:
"let &guicursor = substitute(&guicursor, "n-v-c:", "n-v-c:blinkon0-", "")
" NOTE: To stop all blinking:
" let &guicursor = &guicursor . ",a:blinkon0"
set guicursor+=a:block-blinkon0 "make cursor look square, and prevent cursor blinking

" Yuri Klubakov's sessionman.vim script: disable automatic session saves
" on exit
let sessionman_save_on_exit = 0

" Set maximum number of tabs on startup to 50, instead of the default 10
"
" If you exceed the number of tabs allowed by tabpagemax Vim will simply open the maximum number of tabs, and the other files will be open but not displayed. You can edit the remaining files by using the :next or :last command to move to the files that are not displayed in a tab. Note that this setting only applies to the maximum number of tabs Vim will open on startup -- you can still open more tabs during your Vim session.
set tabpagemax=50

" wait 1 second instead of 0.5 seconds before erasing any "half-finished"
" commands in normal/visual mode
set timeoutlen=1000

" we use a custom, local-to-buffer mod-key so that we don't conflict with any possible bindings provided by a plugin
let maplocalleader = ","

" we only want to load autocommands ONCE (esp. for gvim, which sources the
" vimrc
if !exists("autocommands_loaded")
    let autocommands_loaded = 1
    " custom configobj (python module) syntax highlighting
    au BufRead,BufNewFile *.configobj set filetype=configobj
    au! Syntax configobj source $HOME/.vim/syntax/configobj.vim
    au BufRead,BufNewFile *.lhp set filetype=lhp
    au! Syntax lhp source $HOME/.vim/syntax/lhp.vim

    au BufRead,BufNewFile *.toucan set filetype=toucan
    au! Syntax toucan source $HOME/.vim/syntax/toucan.vim

    " tabstop is how wide the <TAB> character is, whether it's an actual <TAB>
    " character or converted into space characters with expandtab
    au BufRead,BufNewFile *.rb,*.py set tabstop=4
    " shiftwidth is how many characters are used when auto-indenting, and also
    " when typing '>>' and '<<' in normal mode
    au BufRead,BufNewFile *.rb,*.py set shiftwidth=4
" Note that vim's 'textwidth' only really works for COMMENT lines, as doing so otherwise would break whitespace-sensitive code (like Python)
    au BufRead,BufNewFile *.rb,*.py set textwidth=120
    au BufRead,BufNewFile *.c,*.cpp,*.h,*.hpp set tabstop=8
    au BufRead,BufNewFile *.c,*.cpp,*.h,*.hpp set shiftwidth=8
    au BufRead,BufNewFile *.c,*.cpp,*.h,*.hpp set textwidth=120
    au BufRead .vimperatorrc set syn=vim " use vim script syntax highlighting
    " load lilypond-specific stuff
    au BufRead,BufNewFile *.ly set filetype=lilypond
    au! Syntax lilypond source $HOME/.vim/syntax/lilypond.vim

    " Integration with the "boxes" program by Thomas Jensen.
    " Default width is set at 100 characters
    au BufEnter * nmap <localleader>c1 !!boxes -d pound-alt<CR>
    au BufEnter * vmap <localleader>c1 !boxes -d pound-alt<CR>
    au BufEnter * nmap <localleader>cw1 !!boxes -d pound-alt -s 120<CR>
    au BufEnter * vmap <localleader>cw1 !boxes -d pound-alt -s 120<CR>
    au BufEnter * nmap <localleader>C1 !!boxes -d pound-alt -r<CR>
    au BufEnter * vmap <localleader>C1 !boxes -d pound-alt -r<CR>
    au BufEnter * nmap <localleader>c2 !!boxes -d pound-cmt<CR>
    au BufEnter * vmap <localleader>c2 !boxes -d pound-cmt<CR>
    au BufEnter * nmap <localleader>C2 !!boxes -d pound-cmt -r<CR>
    au BufEnter * vmap <localleader>C2 !boxes -d pound-cmt -r<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <localleader>c1 !!boxes -d c-top<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <localleader>c1 !boxes -d c-top<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <localleader>cw1 !!boxes -d c-top -s 120<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <localleader>cw1 !boxes -d c-top -s 120<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <localleader>C1 !!boxes -d c-top -r<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <localleader>C1 !boxes -d c-top -r<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <localleader>c2 !!boxes -d c-mid<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <localleader>c2 !boxes -d c-mid<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <localleader>cw2 !!boxes -d c-mid -s 120<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <localleader>cw2 !boxes -d c-mid -s 120<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <localleader>C2 !!boxes -d c-mid -r<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <localleader>C2 !boxes -d c-mid -r<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <localleader>c3 !!boxes -d c-bot<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <localleader>c3 !boxes -d c-bot<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <localleader>cw3 !!boxes -d c-bot -s 120<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <localleader>cw3 !boxes -d c-bot -s 120<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <localleader>C3 !!boxes -d c-bot -r<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <localleader>C3 !boxes -d c-bot -r<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <localleader>c4 !!boxes -d java-cmt<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <localleader>c4 !boxes -d java-cmt<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap <localleader>C4 !!boxes -d java-cmt -r<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap <localleader>C4 !boxes -d java-cmt -r<CR>
    au BufEnter .vimrc,.gvimrc,.vimperatorrc nmap <localleader>c1 !!boxes -d vim-cmt<CR>
    au BufEnter .vimrc,.gvimrc,.vimperatorrc vmap <localleader>c1 !boxes -d vim-cmt<CR>
    au BufEnter .vimrc,.gvimrc,.vimperatorrc nmap <localleader>cw1 !!boxes -d vim-cmt -s 120<CR>
    au BufEnter .vimrc,.gvimrc,.vimperatorrc vmap <localleader>cw1 !boxes -d vim-cmt -s 120<CR>
    au BufEnter .vimrc,.gvimrc,.vimperatorrc nmap <localleader>C1 !!boxes -d vim-cmt -r<CR>
    au BufEnter .vimrc,.gvimrc,.vimperatorrc vmap <localleader>C1 !boxes -d vim-cmt -r<CR>
    au BufEnter *.ly,*.tex nmap <localleader>c1 !!boxes -d percent<CR>
    au BufEnter *.ly,*.tex vmap <localleader>c1 !boxes -d percent<CR>
    au BufEnter *.ly,*.tex nmap <localleader>cw1 !!boxes -d percent -s 120<CR>
    au BufEnter *.ly,*.tex vmap <localleader>cw1 !boxes -d percent -s 120<CR>
    au BufEnter *.ly,*.tex nmap <localleader>C1 !!boxes -d percent -r<CR>
    au BufEnter *.ly,*.tex vmap <localleader>C1 !boxes -d percent -r<CR>
    au BufEnter *.ly,*.tex nmap <localleader>c2 !!boxes -d percent-line<CR>
    au BufEnter *.ly,*.tex vmap <localleader>c2 !boxes -d percent-line<CR>
    au BufEnter *.ly,*.tex nmap <localleader>C2 !!boxes -d percent-line -r<CR>
    au BufEnter *.ly,*.tex vmap <localleader>C2 !boxes -d percent-line -r<CR>
    au BufEnter *.hs nmap <localleader>c1 !!boxes -d ada-box<CR>
    au BufEnter *.hs vmap <localleader>c1 !boxes -d ada-box<CR>
    au BufEnter *.hs nmap <localleader>cw1 !!boxes -d ada-box -s 120<CR>
    au BufEnter *.hs vmap <localleader>cw1 !boxes -d ada-box -s 120<CR>
    au BufEnter *.hs nmap <localleader>C1 !!boxes -d ada-box -r<CR>
    au BufEnter *.hs vmap <localleader>C1 !boxes -d ada-box -r<CR>
    au BufEnter *.hs nmap <localleader>c2 !!boxes -d ada-cmt<CR>
    au BufEnter *.hs vmap <localleader>c2 !boxes -d ada-cmt<CR>
    au BufEnter *.hs nmap <localleader>C2 !!boxes -d ada-cmt -r<CR>
    au BufEnter *.hs vmap <localleader>C2 !boxes -d ada-cmt -r<CR>
    au BufEnter *.tex vmap <localleader>bb iwoiw"zs\textbf{<C-R>z}<Esc>
    au BufEnter *.tex vmap <localleader>ii iwoiw"zs\textit{<C-R>z}<Esc>
    au BufEnter *.tex vmap <localleader>bi iwoiw"zs\textbf{\textit{<C-R>z}}<Esc>
    au BufEnter *.tex vmap <localleader>sc iwoiw"zs\textsc{<C-R>z}<Esc>
    au BufEnter *.tex vmap <localleader>mbb "zs\textbf{<C-R>z}<Esc>
    au BufEnter *.tex vmap <localleader>mii "zs\textit{<C-R>z}<Esc>
    au BufEnter *.tex vmap <localleader>mbi "zs\textbf{\textit{<C-R>z}}<Esc>
    au BufEnter *.tex vmap <localleader>msc "zs\textsc{<C-R>z}<Esc>
    au BufEnter *.tex nmap <localleader>bb viw"zs\textbf{<C-R>z}<Esc>
    au BufEnter *.tex nmap <localleader>ii viw"zs\textit{<C-R>z}<Esc>
    au BufEnter *.tex nmap <localleader>bi viw"zs\textbf{\textit{<C-R>z}}<Esc>
    au BufEnter *.tex nmap <localleader>sc viw"zs\textsc{<C-R>z}<Esc>

    " useful for selecting multi-word phrases; you can select either
    " right-to-left or left-to-right -- just highlight a portion of the two
    " leftmost and rightmost words in the phrase
    au BufEnter *.lhp vmap <localleader>bb iwoiw"zsb[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <localleader>ii iwoiw"zsi[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <localleader>u  iwoiw"zsu[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <localleader>bi iwoiw"zsbi[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <localleader>bu iwoiw"zsbu[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <localleader>iu iwoiw"zsiu[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <localleader>cc iwoiw"zsc[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <localleader>cp iwoiw"zscp[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <localleader>sc iwoiw"zssc[[<C-R>z]]<Esc>
    " useful for manually selecting the exact boundaries
    au BufEnter *.lhp vmap <localleader>mbb "zsb[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <localleader>mii "zsi[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <localleader>mu  "zsu[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <localleader>mbi "zsbi[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <localleader>mbu "zsbu[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <localleader>miu "zsiu[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <localleader>mcc "zsc[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <localleader>mcp "zscp[[<C-R>z]]<Esc>
    au BufEnter *.lhp vmap <localleader>msc "zssc[[<C-R>z]]<Esc>
    " useful for highlighting a single word from normal mode (just hover a
    " cursor over the single word you want to tag)
    au BufEnter *.lhp nmap <localleader>bb viw"zsb[[<C-R>z]]<Esc>
    au BufEnter *.lhp nmap <localleader>ii viw"zsi[[<C-R>z]]<Esc>
    au BufEnter *.lhp nmap <localleader>u  viw"zsu[[<C-R>z]]<Esc>
    au BufEnter *.lhp nmap <localleader>bi viw"zsbi[[<C-R>z]]<Esc>
    au BufEnter *.lhp nmap <localleader>bu viw"zsbu[[<C-R>z]]<Esc>
    au BufEnter *.lhp nmap <localleader>iu viw"zsiu[[<C-R>z]]<Esc>
    au BufEnter *.lhp nmap <localleader>cc viw"zsc[[<C-R>z]]<Esc>
    au BufEnter *.lhp nmap <localleader>cp viw"zscp[[<C-R>z]]<Esc>
    au BufEnter *.lhp nmap <localleader>sc viw"zssc[[<C-R>z]]<Esc>
    " for quickly inserting a newline, but with one less indent than above
    " (useful for quickly entering a heading 1 - 9; i.e., no more pressing 'o'
    " and then pressing backspace 4 times
    au BufEnter *.lhp nmap <CR> o<Backspace><Backspace><Backspace><Backspace>
    " for automatically creating folds based on the indent
    au BufEnter *.lhp set foldmethod=indent

    " highlight red any trailing whitespace
    highlight ExtraWhitespace ctermbg=red guibg=red
    au ColorScheme * highlight ExtraWhitespace guibg=red
    au BufEnter * match ExtraWhitespace /\s\+$/
    au InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
    au InsertLeave * match ExtraWhiteSpace /\s\+$/

    " always run highlighting regex from the beginning of the file, not just
    " what is displayed on-screen (useful for multiline highlighting patterns)
    au BufEnter *.toucan :syntax sync fromstart

    " function Insert_newline_smartly()
    "     if col(".") != 1
    "         normal o
    "     endif
    " endfunction
    function Toggle_status_bar()
        if &laststatus < 2
            let &laststatus = 2
        else
            let &laststatus = 1 " set it back to Vim's default
        endif
    endfunction
endif

" NOTE: the <F1> key in normal mode is mapped to ":help" by default
" quicksave files
nmap <F1> :w<CR>
imap <F1> <Esc>:w<CR>a
nmap <localleader>w :w<CR>

" exit
nmap <F2> :q<CR>
imap <F2> <Esc>:q<CR>
nmap <localleader>q :q<CR>
nmap <localleader>Q :q!<CR>

" save and exit (equivalent to "ZZ")
nmap <localleader>x :x<cr>

" toggle search highlighting
map <F3> <esc>:noh<cr>

" programming commands
imap <F5> <Esc>:!g++ -Wall -mtune=native -m32 % -o ~/prog/temp32<CR>
imap <F6> <Esc>:!xterm -hold -e ~/prog/temp32<CR>
nmap <F6> <Esc>:!xterm -hold -e ~/prog/temp32<CR>

" Use <F9> to toggle between 'paste' and 'nopaste'
set pastetoggle=<F9>

" make windows equal in height/width
nmap <F10> <C-w>=
imap <F10> <C-w>=

" toggle status bar
nmap <silent> <F11> :call Toggle_status_bar()<CR>
imap <silent> <F11> <Esc>:call Toggle_status_bar()<CR>

" toggle line numbers
nmap <F12> :set number!<CR>
imap <F12> <Esc>:set number!<CR>

" integration with the sessionman.vim plugin by Yuri Klubakov
nmap <localleader>so :SessionOpen<space>
nmap <localleader>ss :SessionSave<CR>
nmap <localleader>sa :SessionSaveAs<space>

" move across tabs
nnoremap <C-l> :tabnext<CR>
nnoremap <C-h> :tabprevious<CR>
inoremap <C-l> <Esc>:tabnext<CR>
inoremap <C-h> <Esc>:tabprevious<CR>

" window movement (i.e., moving around INSIDE a tab)
nmap <Tab> <C-w><C-w>
"inoremap <S-Tab> <Esc><C-w><C-w>

" buffer movement (i.e., moving around INSIDE a window)
nmap <S-h> :bn<CR>
nmap <S-l> :bp<CR>

" faster access to normal mode
imap jj <Esc>

" makes j and k move up or down 1 "line" as it appears on the screen -- not by
" the actual number of lines in the text file
nmap k gk
nmap j gj
nnoremap <c-k> k
nnoremap <c-j> j

nnoremap <space> 10<c-e>10j
nnoremap <backspace> 10<c-y>10k

" find lines longer than 120 characters
nmap <localleader>fl /^.\{-}\zs.\%>79v<cr>

" open buffer to current directory's contents
nmap <localleader>D :e<space>.<cr>

" create a new blank tab
nmap <localleader>n :tabe<cr>
" create a new tab showing the contents of the current directory
nmap <localleader>N :tabe<space>.<cr>

" horizontally/vertically split current window
nmap <localleader>h :sp<cr>
nmap <localleader>H :sp<space>.<cr>
nmap <localleader>v :vsp<cr>
nmap <localleader>V :vsp<space>.<cr>

" Date and time -- various formats
" show current full date, with day name, followed by arrow
nmap <silent> <localleader>df :r<space>!<space>~/syscfg/shellscripts/sys/time.rb<space>0<cr>A<Space>-><Space>
" show current full date, with week number (with Sunday as the first day of a "week"), inside a comment box
nmap <silent> <localleader>ds i###############<Esc>o#<space><C-R>=strftime("%Y%m%d %U")<esc><space>#<Esc>o###############<esc>

" special shortcuts for editing human-made notes quickly
" append a line with a timestamp to denote when that note was created
" task CREATED
nmap <silent> <localleader>tc A<space>[@<space><esc>:r<space>!~/syscfg/shellscripts/sys/time.rb<space>1<cr>I<backspace><esc>A]<esc>
" task DONE
nmap <silent> <localleader>td 0^a><space>[X]<esc>A<space>[<esc>:r<space>!~/syscfg/shellscripts/sys/time.rb<space>0<cr>I<backspace><esc>A]<esc>0<cr>
" task MODIFIED and COMPLETED
nmap <silent> <localleader>tmd 0^a><space>[X~]<esc>A<space>[<esc>:r<space>!~/syscfg/shellscripts/sys/time.rb<space>0<cr>I<backspace><esc>A]<space>=><space>
" task CANCELLED
nmap <silent> <localleader>tC 0^a><space>[/]<esc>A<space>[<esc>:r<space>!~/syscfg/shellscripts/sys/time.rb<space>0<cr>I<backspace><esc>A]<space>=><space>
