set number "line numbers
set nobackup
set tabstop=8
set shiftwidth=8
set expandtab
syntax enable "enable syntax highlighting
set hlsearch "turn on search highlighting
filetype indent on "turn on automatic indenting, as well as filetype recognition

set guioptions-=T  "remove toolbar
set guioptions-=m  "remove menu
set guioptions-=r  "remove scrollbar
set lbr "for word wrapping to be based on words, not characters
set gfn=Terminus\ 11
" so zenburn's background is properly loaded ... 2008/12/23
set t_Co=256
if has('gui_running')
    colorscheme colorful_mod
else
    colorscheme zenburn_mod
endif

" Turn off blinking for the n, v, & c states:
"let &guicursor = substitute(&guicursor, "n-v-c:", "n-v-c:blinkon0-", "")
" NOTE: To stop all blinking:
" let &guicursor = &guicursor . ",a:blinkon0"
set guicursor+=a:block-blinkon0 "make cursor look square, and prevent cursor blinking

" Yuri Klubakov's sessionman.vim script: disable automatic session saves
" on exit
let sessionman_save_on_exit = 0

" Set maximum number of tabs on startup to 50, instead of the default 10
"
" If you exceed the number of tabs allowed by tabpagemax Vim will simply open the maximum number of tabs, and the other files will be open but not displayed. You can edit the remaining files by using the :next or :last command to move to the files that are not displayed in a tab. Note that this setting only applies to the maximum number of tabs Vim will open on startup -- you can still open more tabs during your Vim session.
set tabpagemax=50

" wait 10 seconds instead of 0.5 seconds before erasing any "half-finished"
" commands in normal/visual mode
set timeoutlen=10000

" we only want to load autocommands ONCE (esp. for gvim, which sources the
" vimrc
if !exists("autocommands_loaded")
    let autocommands_loaded = 1
    " custom configobj (python module) syntax highlighting
    au BufRead,BufNewFile *.configobj set filetype=configobj
    au! Syntax configobj source $HOME/.vim/syntax/configobj.vim
    au BufRead,BufNewFile *.lhp set filetype=lhp
    au! Syntax lhp source $HOME/.vim/syntax/lhp.vim
    au BufRead,BufNewFile *.rb set textwidth=120
" Note that vim's 'textwidth' only really works for COMMENT lines, as doing so otherwise would break whitespace-sensitive code (like Python)
    au BufRead,BufNewFile *.py set textwidth=120
    au BufRead,BufNewFile *.c set textwidth=120
    au BufRead,BufNewFile *.C set textwidth=120
    au BufRead,BufNewFile *.cpp set textwidth=120
    au BufRead,BufNewFile *.cxx set textwidth=120
    au BufRead .vimperatorrc set syn=vim " use vim script syntax highlighting
    " load lilypond-specific stuff
    au BufRead,BufNewFile *.ly set filetype=lilypond
    au! Syntax lilypond source $HOME/.vim/syntax/lilypond.vim
    "au! Syntax lilypond source /usr/share/lilypond/2.12.2/vim/syntax/lilypond.vim

    " Integration with the "boxes" program by Thomas Jensen.
    " Default width is set at 100 characters
    au BufEnter * nmap ,c1 !!boxes -d pound-alt<CR>
    au BufEnter * vmap ,c1 !boxes -d pound-alt<CR>
    au BufEnter * nmap ,cw1 !!boxes -d pound-alt -s 120<CR>
    au BufEnter * vmap ,cw1 !boxes -d pound-alt -s 120<CR>
    au BufEnter * nmap ,x1 !!boxes -d pound-alt -r<CR>
    au BufEnter * vmap ,x1 !boxes -d pound-alt -r<CR> 
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap ,c1 !!boxes -d c-top<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap ,c1 !boxes -d c-top<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap ,cw1 !!boxes -d c-top -s 120<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap ,cw1 !boxes -d c-top -s 120<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap ,x1 !!boxes -d c-top -r<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap ,x1 !boxes -d c-top -r<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap ,c2 !!boxes -d c-mid<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap ,c2 !boxes -d c-mid<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap ,cw2 !!boxes -d c-mid -s 120<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap ,cw2 !boxes -d c-mid -s 120<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap ,x2 !!boxes -d c-mid -r<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap ,x2 !boxes -d c-mid -r<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap ,c3 !!boxes -d c-bot<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap ,c3 !boxes -d c-bot<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap ,cw3 !!boxes -d c-bot -s 120<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap ,cw3 !boxes -d c-bot -s 120<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp nmap ,x3 !!boxes -d c-bot -r<CR>
    au BufEnter *.C,*.cpp,*.cxx,*.h,*.hpp vmap ,x3 !boxes -d c-bot -r<CR>
    au BufEnter .vimrc,.gvimrc,.vimperatorrc nmap ,c1 !!boxes -d vim-cmt<CR>
    au BufEnter .vimrc,.gvimrc,.vimperatorrc vmap ,c1 !boxes -d vim-cmt<CR>
    au BufEnter .vimrc,.gvimrc,.vimperatorrc nmap ,cw1 !!boxes -d vim-cmt -s 120<CR>
    au BufEnter .vimrc,.gvimrc,.vimperatorrc vmap ,cw1 !boxes -d vim-cmt -s 120<CR>
    au BufEnter .vimrc,.gvimrc,.vimperatorrc nmap ,x1 !!boxes -d vim-cmt -r<CR>
    au BufEnter .vimrc,.gvimrc,.vimperatorrc vmap ,x1 !boxes -d vim-cmt -r<CR>
    au BufEnter *.ly nmap ,c1 !!boxes -d percent<CR>
    au BufEnter *.ly vmap ,c1 !boxes -d percent<CR>
    au BufEnter *.ly nmap ,cw1 !!boxes -d percent -s 120<CR>
    au BufEnter *.ly vmap ,cw1 !boxes -d percent -s 120<CR>
    au BufEnter *.ly nmap ,x1 !!boxes -d percent -r<CR>
    au BufEnter *.ly vmap ,x1 !boxes -d percent -r<CR>
    function Insert_newline_smartly()
        if col(".") != 1
            normal o
        endif
    endfunction
endif

" quickly enter current date and time
" NOTE: the <F1> key in normal mode is mapped to ":help" by default
map <F1> :call Insert_newline_smartly()<CR>i<C-R>=strftime("%F (%a) %T")<Esc><Space>-><Space>
imap <F1> <Esc>:call Insert_newline_smartly()<CR>i<C-R>=strftime("%F (%a) %T")<Esc><Space>-><Space>

" exit
map <F2> :q<CR>
imap <F2> <Esc>:q<CR>

" turn off search highlighting (to turn on, press 'n' in normal mode for next
" term)
map <F3> :noh<CR>
imap <F3> <Esc>:noh<CR>

" quicksave files
map <F4> :w<CR>
imap <F4> <Esc>:w<CR>a

" programming commands
imap <F5> <Esc>:!g++ -Wall -mtune=native -m32 % -o ~/prog/temp32<CR>
imap <F6> <Esc>:!xterm -hold -e ~/prog/temp32<CR>
map <F6> <Esc>:!xterm -hold -e ~/prog/temp32<CR>

" toggle line numbers
map <F12> :set number!<CR>
imap <F12> <Esc>:set number!<CR>

" makes j and k move up or down 1 "line" as it appears on the screen -- not by
" the actual number of lines in the text file
nnoremap k gk
nnoremap j gj

nnoremap <C-n> :tabnext<CR>
nnoremap <C-p> :tabprevious<CR>
