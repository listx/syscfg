set nocp " take the Vi straitjacket off
set ffs=unix,dos " prefer unix newlines whenever possible, but let dos be dos
set cm=blowfish " if encrypting a new file, use blowfish cipher
set nobackup
" default tabstop and shiftwidths
set tabstop=4
set shiftwidth=4
set expandtab

" When the page starts to scroll, keep the cursor 3 lines from the top and 3
" lines from the bottom (i.e., keep the cursor with at least 3 lines of
" context)
set scrolloff=3

" gvim: Automatically read a file that has changed on disk (useful when
" changing branches in git)
set autoread

" place help page on its own tab
cabbrev help tab h

" see ":help statusline" for more information about status lines, as well as
" the default "standard" one
"
set statusline=%<%F\ %h%m%r%=%-14.(%l,%c%V%)\ %P\ %L
set laststatus=2
syntax enable "enable syntax highlighting
set hlsearch "turn on search highlighting
filetype indent on "turn on automatic indenting based on filetype recognition
filetype plugin on "automatically load the corresponding filetype plugin if we've detected a filetype

set incsearch " search any match IMMEDIATELY

set mousehide " hide the mouse cursor when typing (only for GVIM)

set guioptions-=T  "remove toolbar
set guioptions-=m  "remove menu
 "remove scrollbars
set guioptions-=l
set guioptions-=r
 "remove scrollbars when there is a vertically split window
set guioptions-=L
set guioptions-=R
set lbr "for word wrapping to be based on words, not characters
set gfn=Terminus\ 11
set cursorline " highlight cursor horizontally
" so zenburn's background is properly loaded ... 2008/12/23
set t_Co=256

" choose the appropriate colorscheme, based on the custom
" TERM_COLOR_SCHEME_CURRENT environment variable
if $TERM != 'linux'
    if $TERM_COLOR_SCHEME_CURRENT == 'wb' " white on black
        colorscheme zenburn_mod2
    elseif $TERM_COLOR_SCHEME_CURRENT == 'wB' " white on blue
        colorscheme darkblue2-ex
    elseif $TERM_COLOR_SCHEME_CURRENT == 'bw' " black on white
        colorscheme mayansmoke
    else
        colorscheme zenburn_mod2 " always default to the white on black theme
    endif
else " if we are in a virtual console, use a simple colorscheme
    colorscheme delek
endif

" Turn off blinking for the n, v, & c states:
"let &guicursor = substitute(&guicursor, "n-v-c:", "n-v-c:blinkon0-", "")
" NOTE: To stop all blinking:
" let &guicursor = &guicursor . ",a:blinkon0"
set guicursor+=a:block-blinkon0 "make cursor look square, and prevent cursor blinking

" Set maximum number of tabs on startup to 50, instead of the default 10
"
" If you exceed the number of tabs allowed by tabpagemax Vim will simply open the maximum number of tabs, and the other files will be open but not displayed. You can edit the remaining files by using the :next or :last command to move to the files that are not displayed in a tab. Note that this setting only applies to the maximum number of tabs Vim will open on startup -- you can still open more tabs during your Vim session.
set tabpagemax=50

" wait 1 second instead of 0.5 seconds before erasing any "half-finished"
" commands in normal/visual mode
"
set timeoutlen=1000

" we use a custom, local-to-buffer mod-key so that we don't conflict with any possible bindings provided by a plugin
let maplocalleader = ","

" we only want to load autocommands ONCE (esp. for gvim, which sources the
" vimrc
set runtimepath+=/usr/share/lilypond/2.15.21/vim
if !exists("autocommands_loaded")
    let autocommands_loaded = 1

    " tabstop is how wide the <TAB> character is, whether it's an actual <TAB>
    " character or converted into space characters with expandtab
    au BufRead,BufNewFile *.rb,*.py setlocal tabstop=4
    " shiftwidth is how many characters are used when auto-indenting, and also
    " when typing '>>' and '<<' in normal mode
    au BufRead,BufNewFile *.rb,*.py setlocal shiftwidth=4
" Note that vim's 'textwidth' only really works for COMMENT lines, as doing so otherwise would break whitespace-sensitive code (like Python)
    au BufRead,BufNewFile *.rb,*.py setlocal textwidth=80
    au BufRead,BufNewFile *.sh setlocal textwidth=80
    au BufRead,BufNewFile *.c,*.cpp,*.h,*.hpp setlocal textwidth=80
	" use Linux Kernel tab style for C/C++
    au BufRead,BufNewFile *.c,*.cpp,*.h,*.hpp setlocal tabstop=8
    au BufRead,BufNewFile *.c,*.cpp,*.h,*.hpp setlocal softtabstop=8
    au BufRead,BufNewFile *.c,*.cpp,*.h,*.hpp setlocal shiftwidth=8
    au BufRead,BufNewFile *.c,*.cpp,*.h,*.hpp setlocal noexpandtab
    " try to mimic Linux Kernel Coding Style's indentation style
    au BufRead,BufNewFile *.c,*.cpp,*.h,*.hpp setlocal cinoptions=:0,l1,t0,g0,(0

    au BufRead,BufNewFile *.hs setlocal textwidth=80
    au BufRead,BufNewFile *.hs setlocal tabstop=4
    au BufRead,BufNewFile *.hs setlocal softtabstop=4
    au BufRead,BufNewFile *.hs setlocal shiftwidth=4
    au BufRead,BufNewFile *.hs setlocal noexpandtab

    " load lilypond-specific stuff
    au BufRead,BufNewFile *.ly setlocal filetype=lilypond

    " Integration with my "nox" program.
    au BufEnter * nmap <localleader>c !!~/prog/nox/src/nox<cr>
    au BufEnter * vmap <localleader>c !~/prog/nox/src/nox<cr>
    au BufEnter * nmap <localleader>C !!~/prog/nox/src/nox -u<cr>
    au BufEnter * vmap <localleader>C !~/prog/nox/src/nox -u<cr>
    au BufEnter *.c,*.cpp,*.h,*.hpp nmap <localleader>c1 !!/prog/nox/src/nox -l c<cr>
    au BufEnter *.c,*.cpp,*.h,*.hpp vmap <localleader>c1 !/prog/nox/src/nox -l c<cr>
    au BufEnter *.c,*.cpp,*.h,*.hpp nmap <localleader>CC !!/prog/nox/src/nox -l c -u<cr>
    au BufEnter *.c,*.cpp,*.h,*.hpp vmap <localleader>CC !/prog/nox/src/nox -l c -u<cr>
    au BufEnter *.ly,*.tex nmap <localleader>c1 !!/prog/nox/src/nox -l tex<cr>
    au BufEnter *.ly,*.tex vmap <localleader>c1 !/prog/nox/src/nox -l tex<cr>
    au BufEnter *.ly,*.tex nmap <localleader>CC !!/prog/nox/src/nox -l tex -u<cr>
    au BufEnter *.ly,*.tex vmap <localleader>CC !/prog/nox/src/nox -l tex -u<cr>
    au BufEnter *.hs nmap <localleader>c1 !!/prog/nox/src/nox -l hs<cr>
    au BufEnter *.hs vmap <localleader>c1 !/prog/nox/src/nox -l hs<cr>
    au BufEnter *.hs nmap <localleader>CC !!/prog/nox/src/nox -l hs -u<cr>
    au BufEnter *.hs vmap <localleader>CC !/prog/nox/src/nox -l hs -u<cr>
    au BufEnter *.html vmap <localleader>bb iwoiw"zs<strong><C-R>z</strong><esc>
    au BufEnter *.html vmap <localleader>ii iwoiw"zs<em><C-R>z</em><esc>
    au BufEnter *.html vmap <localleader>bi iwoiw"zs<em><strong><C-R>z</strong></em><esc>
    au BufEnter *.html vmap <localleader>tt iwoiw"zs<pre><C-R>z</pre><esc>
    au BufEnter *.html vmap <localleader>mbb "zs<strong><C-R>z</strong><esc>
    au BufEnter *.html vmap <localleader>mii "zs<em><C-R>z</em><esc>
    au BufEnter *.html vmap <localleader>mbi "zs<em><strong><C-R>z</strong></em><esc>
    au BufEnter *.html vmap <localleader>mtt "zs<pre><C-R>z</pre><esc>
    au BufEnter *.html nmap <localleader>bb viw"zs<strong><C-R>z</strong><esc>
    au BufEnter *.html nmap <localleader>ii viw"zs<em><C-R>z</em><esc>
    au BufEnter *.html nmap <localleader>bi viw"zs<em><strong><C-R>z</strong></em><esc>
    au BufEnter *.html nmap <localleader>tt viw"zs<pre><C-R>z</pre><esc>
    au BufEnter *.tex vmap <localleader>bb iwoiw"zs\textbf{<C-R>z}<esc>
    au BufEnter *.tex vmap <localleader>ii iwoiw"zs\textit{<C-R>z}<esc>
    au BufEnter *.tex vmap <localleader>bi iwoiw"zs\textbf{\textit{<C-R>z}}<esc>
    au BufEnter *.tex vmap <localleader>bu iwoiw"zs\textbf{\uline{<C-R>z}}<esc>
    au BufEnter *.tex vmap <localleader>u  iwoiw"zs\uline{<C-R>z}<esc>
    au BufEnter *.tex vmap <localleader>sc iwoiw"zs\textsc{<C-R>z}<esc>
    au BufEnter *.tex vmap <localleader>sf iwoiw"zs\textsf{<C-R>z}<esc>
    au BufEnter *.tex vmap <localleader>tt iwoiw"zs\texttt{<C-R>z}<esc>
    au BufEnter *.tex vmap <localleader>mbb "zs\textbf{<C-R>z}<esc>
    au BufEnter *.tex vmap <localleader>mii "zs\textit{<C-R>z}<esc>
    au BufEnter *.tex vmap <localleader>mbi "zs\textbf{\textit{<C-R>z}}<esc>
    au BufEnter *.tex vmap <localleader>mbu "zs\textbf{\uline{<C-R>z}}<esc>
    au BufEnter *.tex vmap <localleader>mu  "zs\uline{<C-R>z}<esc>
    au BufEnter *.tex vmap <localleader>msc "zs\textsc{<C-R>z}<esc>
    au BufEnter *.tex vmap <localleader>msf "zs\textsf{<C-R>z}<esc>
    au BufEnter *.tex vmap <localleader>mtt "zs\texttt{<C-R>z}<esc>
    au BufEnter *.tex nmap <localleader>bb viw"zs\textbf{<C-R>z}<esc>
    au BufEnter *.tex nmap <localleader>ii viw"zs\textit{<C-R>z}<esc>
    au BufEnter *.tex nmap <localleader>bi viw"zs\textbf{\textit{<C-R>z}}<esc>
    au BufEnter *.tex nmap <localleader>bu viw"zs\textbf{\uline{<C-R>z}}<esc>
    au BufEnter *.tex nmap <localleader>u  viw"zs\uline{<C-R>z}<esc>
    au BufEnter *.tex nmap <localleader>sc viw"zs\textsc{<C-R>z}<esc>
    au BufEnter *.tex nmap <localleader>sf viw"zs\textsf{<C-R>z}<esc>
    au BufEnter *.tex nmap <localleader>tt viw"zs\texttt{<C-R>z}<esc>

    " highlight red any trailing whitespace
    highlight ExtraWhitespace ctermbg=red guibg=red
    au ColorScheme * highlight ExtraWhitespace guibg=red
    au BufEnter * match ExtraWhitespace /\s\+$/
    au InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
    au InsertLeave * match ExtraWhiteSpace /\s\+$/

    " always run highlighting regex from the beginning of the file, not just
    " what is displayed on-screen (useful for multiline highlighting patterns)
    au BufEnter *.toucan :syntax sync fromstart
    au BufEnter *.cog :syntax sync fromstart
    au BufEnter *.hs :syntax sync fromstart

    " function Insert_newline_smartly()
    "     if col(".") != 1
    "         normal o
    "     endif
    " endfunction
    function Toggle_status_bar()
        if &laststatus < 2
            let &laststatus = 2
        else
            let &laststatus = 1 " set it back to Vim's default
        endif
    endfunction

    " kill trailing whitespace
    function KillWhiteSpace()
      %s/\s\+$//
    endfunction

    " replace all /r/n () with /n
    function KillWinNL()
      %s///
    endfunction
endif

" quick copy and paste from CLIPBOARD ("+y and "+p)
vmap <localleader>y "+y
nmap <localleader>p "+p
nmap <localleader>P "+P

" Change K from being mapped to interactive man pages to being used as the
" vanilla comma ',' key's functionality (intra-line backwards search repeat for
" any t, T, f, F searches).
nnoremap K ,
vnoremap K ,

" quicksave files
nmap <localleader>w :up<cr>
" force save
nmap <localleader>W :w<cr>

" exit
nmap <localleader>q :q<cr>
nmap <localleader>Q :q!<cr>

" save and exit (equivalent to "ZZ")
nmap <localleader>x :x<cr>

" >> and << in visual mode
vmap <tab> >gv
vmap <s-tab> <gv

" toggle search highlighting
map <F2> <esc>:noh<cr>

" highlight lines longer than 80 characters
map <F3> <esc>:match ErrorMsg '\%>80v.\+'<cr>

" find lines longer than 80 characters
nmap <localleader>fl /\%>80v.\+<cr>

" remove all trailing whitespace
nmap <silent> <localleader>e :call KillWhiteSpace()<cr>

" replace all /r/n () with /n
nmap <silent> <localleader>E :call KillWinNL()<cr>

" Use <F10> to toggle between 'paste' and 'nopaste'
set pastetoggle=<F10>

" toggle status bar
nmap <silent> <F11> :call Toggle_status_bar()<cr>
imap <silent> <F11> <esc>:call Toggle_status_bar()<cr>

" toggle line numbers
nmap <F12> :if exists("g:syntax_on") <Bar>
    \   syntax off <Bar>
    \ else <Bar>
    \   syntax enable <Bar>
    \ endif <cr>
imap <F12> <esc>:if exists("g:syntax_on") <Bar>
    \   syntax off <Bar>
    \ else <Bar>
    \   syntax enable <Bar>
    \ endif <cr>

" move across tabs
nnoremap <C-l> :tabnext<cr>
nnoremap <C-h> :tabprevious<cr>
inoremap <C-l> <esc>:tabnext<cr>
inoremap <C-h> <esc>:tabprevious<cr>

" window movement (i.e., moving around INSIDE a tab)
nmap <Tab> <C-w><C-w>
"inoremap <S-Tab> <esc><C-w><C-w>

" buffer movement (i.e., moving around INSIDE a window)
nmap <S-h> :bn<cr>
nmap <S-l> :bp<cr>

" faster access to normal mode
imap kj <esc>

nnoremap <space> 10jzz
nnoremap <backspace> 10kzz
vnoremap <space> 10jzz
vnoremap <backspace> 10kzz

" open buffer to current directory's contents
nmap <localleader>D :e<space>.<cr>

" create a new blank tab
nmap <localleader>n :tabe<cr>
" create a new tab showing the contents of the current directory
nmap <localleader>N :tabe<space>.<cr>

" horizontally/vertically split current window
nmap <localleader>h :sp<cr>
nmap <localleader>H :sp<space>.<cr>
nmap <localleader>v :vsp<cr>
nmap <localleader>V :vsp<space>.<cr>

" make <s-insert> input the X selection in gvim, just like in regular vim (under urxvt)
if has ("gui_running")
    imap <s-insert> <middlemouse>
endif

" vim: syntax=vim
