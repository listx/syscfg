#!/usr/bin/env zsh
# kody prompt theme, based on adam2

# preexec() is a hook function under "SPECIAL FUNCTIONS"; it is executed just
# after a command has been read, but before it is executed.
preexec() {
	ran_something=true
}

# precmd() is executed before each prompt.
precmd()
{
	# Catch cases where we press C-c to stop execution (or if we just pressed
	# ENTER after deleting the entire BUFFER); we want to treat such cases as
	# non-error exits. So, if we did not run anything (preexec() did not get
	# executed due to C-c), then assign exit_status as 0.
	exit_status=$?
	if ! $ran_something; then
		exit_status=0
	fi
	ran_something=false
}

maybe_show_exit_status() {
	case $exit_status in
		0) ;;
		*) echo "%B%F{$prompt_color5}$exit_status%b%f " ;;
	esac
}

get_short_pwd()
{
	if [[ "${PWD}" == "${L_PWD_SHORT_PREV#*;}" ]]; then
		return
	fi
	local pwd_short
	pwd_short="$(lhc path-shorten --path-aliases ~/syscfg/zsh/path-aliases "${PWD}" 2>/dev/null || ~/syscfg/lhc/doc/code/simplify_path.sh "${PWD}")"
	export L_PWD_SHORT_PREV="${pwd_short};${PWD}"
}

chpwd() {
	get_short_pwd
}

prompt_kody_setup()
{
	# Usage (if customizing the colors at run time):
	# prompt_kody_setup 8bit <color1> <color2> <color3> ... <color8>

	# if invoked with "8bit" argument, initialize data
	if [[ $1 == '8bit' ]]; then
		shift
	fi

	# Color scheme -- use zsh's parameter expansion form ${NAME:-WORD} (if NAME
	# is set, use it; otherwise if NAME is not set, use WORD in its place)
	# Here, we use the default WORDs cyan, red, white, etc -- these words are
	# zsh-special and can be found in CHARACTER HIGHLIGHTING in zshzle(1). Most
	# terminals support the colours black, red, green, yellow, blue, magenta,
	# cyan and white, which can be set by name. In addition. default  may be used
	# to set the terminal's default foreground colour.  Abbreviations are
	# allowed; b or bl selects black.
	prompt_color1=${1-'cyan'}     # present directory
	prompt_color2=${2-'blue'}
	prompt_color3=${3-'default'}  # user@host (also color of all regular text from commands like ls, cat, etc)
	prompt_color4=${4-'white'}
	prompt_color5=${5-'red'}
	prompt_color6=${6-'green'}
	prompt_color7=${7-'yellow'}
	prompt_color8=${8-'magenta'}

	add-zsh-hook precmd prompt_kody_precmd
	add-zsh-hook chpwd get_short_pwd
}

# The zle-keymap-select and zle-line-finish functions are special widgets that
# are empty by default. See "Special Widgets" in zshzle(1).
zle-line-init zle-keymap-select() {
	case "${KEYMAP}" in
	vicmd)
	__l_zsh_keymap_indicator="%B%K{blue}%F{black} <N> %f%k%b "
	;;
	main|viins)
	__l_zsh_keymap_indicator="%B <I> %b "
	;;
	esac
	# After recalculating the indicator, rebuild the prompt before resetting it.
	# Otherwise the prompt itself does not get re-built (it only gets re-printed
	# using the old state).
	prompt_kody_precmd
	zle reset-prompt
}
zle -N zle-line-init
zle -N zle-keymap-select

# the actual prompt
prompt_kody_precmd()
{
	# Special ZSH Prompt Escape Characters (see 'man zshmisc' for more info on these)
	#
	# Visual effects
	# %B (%b)
	#     Start (stop) boldface mode
	# %F (%f) (used as %F{chosen_color})
	#     Start (stop) using a different foreground color, if supported by the
	#     terminal.  The colour may be specified two ways: either as a numeric
	#     argument, as normal,  or by a sequence in braces following the %F, for
	#     example %F{red}.  In the latter case the values allowed are as
	#     described for the fg zle_high‐ light attribute; see Character
	#     Highlighting in zshzle(1).  This means that numeric colours are allowed
	#     in the second format also.
	#
	# %K (%k)
	#     Start (stop) using a different background color. Same syntax as %F and %f.
	#
	# Other special characters
	#
	# %n      Same as $USERNAME
	#
	# Shell states
	#
	# %M      Full machine hostname
	# %#      A `#' if the shell is running with privileges (e.g., logged in as root), a `%' if not. Equivalent to `%(!.#.%%)'.
	# %?      The return status of the last command executed just before the prompt (the prompt is itself a function that is executed after every command).
	# %~      Shows $PWD, but replaced $HOME with `~'.
	# %*      Current time of day in 24-hour format with seconds (same as %D{%H:%M:%S})
	# %D{string}
	#         string is formatted with the strftime function. See 'man 3 strftime' for more details.

	# Git info (if we're inside a git repo).
	local ginfo_short=""
	ginfo_short="$(lhc git-info "${PWD}" 2>/dev/null || gsts for_prompt)"
	if [[ -n $ginfo_short ]]; then
		ginfo_short="${ginfo_short} "
	fi

	# Python VirtualEnv info.
	local venv=""
	if test -n "${VIRTUAL_ENV}"; then
		venv="($(basename "${VIRTUAL_ENV}")) "
	fi

	day=""
	case $(date +%a) in
		Mon) day="%B%F{$prompt_color2}月%b%f" ;;
		Tue) day="%B%F{$prompt_color2}火%b%f" ;;
		Wed) day="%B%F{$prompt_color2}水%b%f" ;;
		Thu) day="%B%F{$prompt_color2}木%b%f" ;;
		Fri) day="%B%F{$prompt_color8}金%b%f" ;;
		Sat) day="%B%F{$prompt_color6}土%b%f" ;;
		Sun) day="%B%F{$prompt_color6}日%b%f" ;;
	esac

	prompt_kody_time_a="$day %D{%d} %* ${__l_zsh_keymap_indicator}$(maybe_show_exit_status)${ginfo_short}${venv}"
	prompt_kody_time_b="$day %D{%d} %* ${__l_zsh_keymap_indicator}$(maybe_show_exit_status)"
	prompt_kody_time_c="$day %D{%d} %* ${__l_zsh_keymap_indicator}"
	prompt_kody_time_d="%D{%d} %* ${__l_zsh_keymap_indicator}"

	prompt_hostcolor=$prompt_color3
	prompt_charcolor=$prompt_color3
	prompt_username="%F{$prompt_charcolor}%n%f"
	prompt_at_sign="%F{$prompt_color3}@%f"
	prompt_hostname="%F{$prompt_hostcolor}%m%f"
	# set user@host
	prompt_userhost="$prompt_username$prompt_at_sign$prompt_hostname"

	# set display of current working directory
	if [[ -z "${L_PWD_SHORT_PREV:-}" ]]; then
		get_short_pwd
	fi
	prompt_kody_pwd="%B%F{$prompt_color1}${L_PWD_SHORT_PREV%;*}%b%f"

	# three default possibilities for the first prompt line, depending on available screen width space
	prompt_line_1a="$prompt_kody_time_a$prompt_userhost $prompt_kody_pwd"
	prompt_line_1b="$prompt_kody_time_b$prompt_userhost $prompt_kody_pwd"
	prompt_line_1c="$prompt_kody_time_c$prompt_userhost $prompt_kody_pwd"
	prompt_line_1d="$prompt_kody_time_d$prompt_userhost $prompt_kody_pwd"
	prompt_line_1e="$__l_zsh_keymap_indicator$prompt_userhost $prompt_kody_pwd"
	prompt_line_1f="$__l_zsh_keymap_indicator$prompt_kody_pwd"
	prompt_line_2="%B%F{$prompt_color3} "
	# The prompt character to display, based on "CONDITIONAL SUBSTRINGS IN
	# PROMPTS" in zshmisc(1). The `!' tests if the current user is running with
	# privileges, and the periods separate the true and false cases. So if we're
	# root, then display "# ", else "$ ".
	prompt_char="%(!.# .$"

	# choose the correct prompt, depending on screen length
	prompt_kody_choose_prompt

	# PS1 -> what you see by default
	PS1="$prompt_line_1$prompt_newline$prompt_line_2%B%F{$prompt_charcolor}$prompt_char %b%f"
	# PS2 -> what you see when you enter a multi-line shell command
	PS2="$prompt_line_2%B%F{$prompt_charcolor}..%_ > %b%f" # `%_' is a special character that is expanded
	# PS3 -> what you see when you are given a selection option screen (e.g., selecting a directory in the directory stack)
	PS3="$prompt_line_2%B%F{$prompt_charcolor}?# %b%f"
	zle_highlight[(r)default:*]="default:fg=$prompt_charcolor,bold"
}

# See http://www.zsh.org/mla/users/2015/msg00566.html (which references
# http://stackoverflow.com/a/10564427/15690).
visible_length()
{
	local zero='%([BSUbfksu]|([FB]|){*})'
	print ${#${(S%%)1//$~zero}}
}

# Resize the prompt according to the working directory's length.
prompt_kody_choose_prompt()
{
	# Default prompt.
	prompt_line_1="$prompt_l_brack%B%F{$prompt_color2}%$COLUMNS<...<%~%<<$prompt_r_brack%b"

	# Try to set longer prompt lines if we can do it.
	longer_prompt_lines=(
		"$prompt_line_1a"
		"$prompt_line_1b"
		"$prompt_line_1c"
		"$prompt_line_1d"
		"$prompt_line_1e"
		"$prompt_line_1f"
	)
	for line in $longer_prompt_lines; do
		if (( $COLUMNS - $(visible_length "$line") >= 0 )); then
			prompt_line_1=$line;
			break;
		fi
	done

}

prompt_kody_setup "$@"
