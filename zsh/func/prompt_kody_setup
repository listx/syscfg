#!/usr/bin/env zsh
# "kody" prompt theme.

# Allow parameter expansion, command substitution and arithmetic expansion in
# prompts.
setopt PROMPT_SUBST

# The zle-keymap-select and zle-line-finish functions are special widgets that
# are empty by default. We use it to set the Vim-style "<I>" or "<N>" mode
# indicators in the prompt. See "Special Widgets" in zshzle(1).
zle-line-init zle-keymap-select() {
	# After recalculating the indicator, rebuild the prompt before resetting it.
	# Otherwise the prompt itself does not get re-built (it only gets re-printed
	# using the old state).
	set_zsh_keymap_indicator
	construct_prompt
	zle reset-prompt
}
# Create user-defined widgets.
zle -N zle-line-init
zle -N zle-keymap-select

prompt_kody_setup()
{
	# Run construct_prompt() after executing precmd().
	add-zsh-hook precmd construct_prompt

	# Make text typed in by the user be displayed as bold text.
	zle_highlight[(r)default:*]="default:fg=default,bold"
}

# The chpwd(), preexec() and precmd() functions are specially recognized by Zsh.
# Normally they are not defined and hence nothing happens.

# preexec() is a hook function under "SPECIAL FUNCTIONS"; it is executed just
# after a command has been read, but before it is executed.
preexec() {
	# We set the ran_something variable to TRUE to indicate that the user typed
	# in a command to be executed.
	global_ran_something=1
}

# precmd() is executed before each prompt.
precmd()
{
	# Catch cases where we press C-c to stop execution (or if we just pressed
	# ENTER after deleting the entire BUFFER); we want to treat such cases as
	# non-error exits. So, if we did not run anything (preexec() did not get
	# executed due to C-c), then assign global_exit_status as 0.
	global_exit_status=$?
	if ! (( $global_ran_something )); then
		global_exit_status=0
	fi
	global_ran_something=0

	# Set global variables used for prompt generation. This function is only
	# executed once. That is, even in cases where we press ESC to enter "Normal"
	# mode, we do _not_ call this function.
	set_globals
}

# Whenever we change directories, recalculate the shortened named. However, skip
# this calculation if we haven't actually changed directories. This happens when
# we press "ENTER".
chpwd() {
	set_pwd_short_prev
}

set_pwd_short_prev()
{
	if [[ "${PWD}" == "${L_PWD_SHORT_PREV#*;}" ]]; then
		return
	fi
	local pwd_short
	pwd_short="$(lhc path-shorten --path-aliases ~/syscfg/zsh/path-aliases "${PWD}" 2>/dev/null || ~/syscfg/lhc/doc/code/simplify_path.sh "${PWD}")"
	# We have to use an environment variable here to carry state across prompt
	# generation invocations.
	export L_PWD_SHORT_PREV="${pwd_short};${PWD}"
}

# PWD (possibly shortened).
get_short_pwd()
{
	# If we just started a fresh shell instance, then we haven't had a chance to
	# run chpwd() yet. So run it now (to create the very first prompt).
	if [[ -z "${L_PWD_SHORT_PREV:-}" ]]; then
		set_pwd_short_prev
	fi
	echo "%B%F{cyan}${L_PWD_SHORT_PREV%;*}%b%f"
}

set_zsh_keymap_indicator()
{
	case "${KEYMAP}" in
	vicmd)
		global_keymap_indicator="%B%K{blue}%F{black} <N> %f%k%b "
	;;
	main|viins)
		global_keymap_indicator="%B <I> %b "
	;;
	esac
}

# Git info (if we're inside a git repo).
get_git_info()
{
	local git_info_oneline=""
	git_info_oneline="$(lhc git-info "${PWD}" 2>/dev/null || gsts for_prompt)"
	if [[ -n $git_info_oneline ]]; then
		git_info_oneline+=" "
	fi
	echo "${git_info_oneline}"

}

# Python VirtualEnv info.
get_venv_info()
{
	if [[ -n "${VIRTUAL_ENV}" ]]; then
		echo "($(basename "${VIRTUAL_ENV}")) "
	fi
}

get_day()
{
	local day=""
	day="%B%F{blue}"
	case $(date +%a) in
		Mon) day+="月%b%f" ;;
		Tue) day+="火%b%f" ;;
		Wed) day+="水%b%f" ;;
		Thu) day+="木%b%f" ;;
		Fri) day+="金%b%f" ;;
		Sat) day+="土%b%f" ;;
		Sun) day+="日%b%f" ;;
	esac
	echo "${day}"
}

get_user_host()
{
	local prompt_hostname="%m"
	local prompt_hostname_short="$(cat ~/.hostname-short)"
	if [[ -n "${prompt_hostname_short}" ]]; then
		prompt_hostname="${prompt_hostname_short}"
	fi
	echo "%F{default}%n@${prompt_hostname}%f"
}

get_exit_status()
{
	if (( $global_exit_status )); then
		echo "%B%F{red}$global_exit_status%b%f "
	fi
}

set_globals()
{
	global_git_info="$(get_git_info)"
	global_venv_info="$(get_venv_info)"
	global_day="$(get_day)"
	global_pwd="$(get_short_pwd)"
	global_user_host="$(get_user_host)"
	global_cmd_exit_status="$(get_exit_status)"
}

# The actual prompt. This does mostly pure string manipulation as all of the
# data that we want to display has been calculated elsewhere (and set as global
# variables).
#
# The use of global variables here is important because it allows us to avoid
# recalculating costly bits. Practically speaking, we recalculate the keymap
# indicator whenever the user enters or leaves vi mode ("Normal" mode), but we
# do not recalculate the other globals.
construct_prompt()
{
	# Date, time, Zsh keymap indicator, exit code, Git, and VirtualEnv.
	local prompt_kody_time_a="$global_day %D{%d} %* ${global_keymap_indicator}${global_venv_info}${global_cmd_exit_status}${global_git_info}"
	local prompt_kody_time_b="$global_day %D{%d} %* ${global_keymap_indicator}${global_cmd_exit_status}"
	local prompt_kody_time_c="$global_day %D{%d} %* ${global_keymap_indicator}"
	local prompt_kody_time_d="%D{%d} %* ${global_keymap_indicator}"

	# Set multiple possible prompt lines.
	local prompt_line_1a="$prompt_kody_time_a$global_user_host $global_pwd"
	local prompt_line_1b="$prompt_kody_time_b$global_user_host $global_pwd"
	local prompt_line_1c="$prompt_kody_time_c$global_user_host $global_pwd"
	local prompt_line_1d="$prompt_kody_time_d$global_user_host $global_pwd"
	local prompt_line_1e="${global_keymap_indicator}$global_user_host $global_pwd"
	local prompt_line_1f="${global_keymap_indicator}$global_pwd"

	# Set prompt_line_1, depending on available screen width.
	local prompt_line_1=""
	# Default prompt.
	prompt_line_1="$prompt_line_1f"

	# Try to set longer prompt lines if we can do it.
	longer_prompt_lines=(
		"$prompt_line_1a"
		"$prompt_line_1b"
		"$prompt_line_1c"
		"$prompt_line_1d"
		"$prompt_line_1e"
	)

	for line in $longer_prompt_lines; do
		if (( $COLUMNS - $(visible_length "$line") >= 0 )); then
			prompt_line_1=$line;
			break;
		fi
	done

	local prompt_line_2="%B%F{default} "

	# The prompt character to display, based on "CONDITIONAL SUBSTRINGS IN
	# PROMPTS" in zshmisc(1). The `!' tests if the current user is running with
	# privileges, and the periods separate the true and false cases. So if we're
	# root, then display "# ", else "$ ".
	local cursor_prefix="%(!.# .$"

	# PS1 -> what you see by default.
	PS1="$prompt_line_1$prompt_newline${prompt_line_2}%B%F{default}${cursor_prefix} %b%f"
	# PS2 -> what you see when you enter a multi-line shell command.
	PS2="${prompt_line_2}%B%F{default}..%_ > %b%f"
	# PS3 -> what you see when you are given a selection option screen (e.g.,
	# selecting a directory in the directory stack).
	PS3="${prompt_line_2}%B%F{default}?# %b%f"
}

# See http://www.zsh.org/mla/users/2015/msg00566.html (which references
# http://stackoverflow.com/a/10564427/15690).
visible_length()
{
	local zero='%([BSUbfksu]|([FB]|){*})'
	print ${#${(S%%)1//$~zero}}
}

prompt_kody_setup "$@"
