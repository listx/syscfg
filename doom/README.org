#+TITLE: Literate Emacs configuration
#+AUTHOR: Linus Arver
#+PROPERTY: header-args :tangle no :noweb no-export

* Introduction

We use DOOM emacs (insert link) as a base configuration, and further customize it here in literate form.

** About the top-level PROPERTY settings for this buffer
- These property settings take effect when the buffer is loaded. So that means if you change these settings, you have to reload the buffer for them to take effect.
- We set =:tangle no-export= by default for all source code blocks. This is because the =literate= DOOM module by default tangles all elisp source code blocks to config.el, which defeats the purpose of literate programming (where the raw order of how things are defined do **not** dictate how the end result looks like).
- We set =:noweb no-export= to enable Noweb's =<<LINK>>= syntax in all source code blocks during **tangling** (=config.el= generation) and **evaluation** (when running a code snippet from org-mode with =C-c C-c=). However when we export this org-mode file (e.g., publish it to HTML), we do **NOT** expand it because we want to reveal the underlying noweb structure to the reader. Anyway, turning on noweb for tangling and evaluating allows us to inject source code anywhere and also define them freely.

** Guiding principles

- **Modular output**: We make sure that the output file(s) that are "tangled" out of here stay nice and clean in a modular way. We do **NOT** want to have a giant 2000 line file with everything in it with no modularity, because it hurts readability for the case where we want to debug our configuration at the raw Emacs lisp level.

- **Bird's eye view**: We discuss the most important high-level topics first, and leave the finer details at the end.

* How DOOM loads configs

DOOM requires 3 configuration files in the =$DOOMDIR=:

- =init.el=: This is where DOOM "modules" are loaded; modules are just collections of Emacs packages and configurations. This file is pretty small and straightforward.
- =packages.el=: This is where additional packages are installed (or disabled if they are pulled in by DOOM).
- =config.el=: This is where all of our custom configuration goes. Note that this file can pull in other =*.el= files as well if we want to.

* $DOOMDIR/init.el

#+begin_src elisp :tangle init.el
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load
;; in. Remember to run 'doom sync' after modifying it!

;; NOTE Press 'SPC h d h' (or 'C-h d h' for non-vim users) to access Doom's
;;      documentation. There you'll find a "Module Index" link where you'll find
;;      a comprehensive list of Doom's modules and what flags they support.

;; NOTE Move your cursor over a module's name (or its flags) and press 'K' (or
;;      'C-c c k' for non-vim users) to view its documentation. This works on
;;      flags as well (those symbols that start with a plus).
;;
;;      Alternatively, press 'gd' (or 'C-c c d') on a module to browse its
;;      directory (for easy access to its source code).

(doom! :input
       ;;chinese
       ;;japanese
       ;;layout            ; auie,ctsrnm is the superior home row

       :completion
       company           ; the ultimate code completion backend
       ;;helm              ; the *other* search engine for love and life
       ;;ido               ; the other *other* search engine...
       ;;ivy               ; a search engine for love and life
       vertico           ; the search engine of the future

       :ui
       deft              ; notational velocity for Emacs
       doom              ; what makes DOOM look the way it does
       doom-dashboard    ; a nifty splash screen for Emacs
       ;;doom-quit         ; DOOM quit-message prompts when you quit Emacs
       ;;(emoji +unicode)  ; ðŸ™‚
       hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
       hydra
       ;;indent-guides     ; highlighted indent columns
       ;;ligatures         ; ligatures and symbols to make your code pretty again
       ;;minimap           ; show a map of the code on the side
       (modeline +light)         ; snazzy, Atom-inspired modeline, plus API
       ;;nav-flash         ; blink cursor line after big motions
       ;;neotree           ; a project drawer, like NERDTree for vim
       ;;ophints           ; highlight the region an operation acts on
       ;;(popup +all +defaults)   ; tame sudden yet inevitable temporary windows
       ;;tabs              ; a tab bar for Emacs
       ;;treemacs          ; a project drawer, like neotree but cooler
       ;;unicode           ; extended unicode support for various languages
       ;;vc-gutter         ; vcs diff in the fringe
       ;;vi-tilde-fringe   ; fringe tildes to mark beyond EOB
       ;;window-select     ; visually switch windows
       workspaces        ; tab emulation, persistence & separate workspaces
       ;;zen               ; distraction-free coding or writing

       :editor
       (evil +everywhere); come to the dark side, we have cookies
       file-templates    ; auto-snippets for empty files
       fold              ; (nigh) universal code folding
       (format +onsave)  ; automated prettiness
       ;;god               ; run Emacs commands without modifier keys
       lispy             ; vim for lisp, for people who don't like vim
       multiple-cursors  ; editing in many places at once
       (parinfer +rust)         ; turn lisp into python, sort of
       rotate-text       ; cycle region at point between text candidates
       snippets          ; my elves. They type so I don't have to
       word-wrap         ; soft wrapping with language-aware indent

       :emacs
       dired             ; making dired pretty [functional]
       electric          ; smarter, keyword-based electric-indent
       ibuffer         ; interactive buffer management
       undo              ; persistent, smarter undo for your inevitable mistakes
       vc                ; version-control and Emacs, sitting in a tree

       :term
       ;;eshell            ; the elisp shell that works everywhere
       ;;shell             ; simple shell REPL for Emacs
       ;;term              ; basic terminal emulator for Emacs
       vterm             ; the best terminal emulation in Emacs

       :checkers
       syntax              ; tasing you for every semicolon you forget
       (spell +flyspell) ; tasing you for misspelling mispelling
       ;;grammar           ; tasing grammar mistake every you make

       :tools
       ;;ansible
       ;;debugger          ; FIXME stepping through code, to help you add bugs
       ;;direnv
       ;;docker
       editorconfig      ; let someone else argue about tabs vs spaces
       ;;ein               ; tame Jupyter notebooks with emacs
       (eval +overlay)     ; run code, run (also, repls)
       ;;gist              ; interacting with github gists
       lookup              ; navigate your code and its documentation
       lsp               ; M-x vscode
       magit             ; a git porcelain for Emacs
       ;;make              ; run make tasks from Emacs
       ;;pass              ; password manager for nerds
       ;;pdf               ; pdf enhancements
       ;;prodigy           ; FIXME managing external services & code builders
       rgb               ; creating color strings
       ;;taskrunner        ; taskrunner for all your projects
       ;;terraform         ; infrastructure as code
       ;;tmux              ; an API for interacting with tmux
       ;;upload            ; map local to remote projects via ssh/ftp

       :os
       (:if IS-MAC macos)  ; improve compatibility with macOS
       tty               ; improve the terminal Emacs experience

       :lang
       ;;agda              ; types of types of types of types...
       ;;beancount         ; mind the GAAP
       ;;cc                ; C > C++ == 1
       ;;clojure           ; java with a lisp
       common-lisp       ; if you've seen one lisp, you've seen them all
       ;;coq               ; proofs-as-programs
       ;;crystal           ; ruby at the speed of c
       ;;csharp            ; unity, .NET, and mono shenanigans
       data              ; config/data formats
       ;;(dart +flutter)   ; paint ui and not much else
       dhall
       (elixir +lsp)           ; erlang done right
       ;;elm               ; care for a cup of TEA?
       emacs-lisp        ; drown in parentheses
       ;;erlang            ; an elegant language for a more civilized age
       ;;ess               ; emacs speaks statistics
       ;;factor
       ;;faust             ; dsp, but you get to keep your soul
       ;;fsharp            ; ML stands for Microsoft's Language
       ;;fstar             ; (dependent) types and (monadic) effects and Z3
       ;;gdscript          ; the language you waited for
       (go +lsp)         ; the hipster dialect
       (haskell +lsp)  ; a language that's lazier than I am
       ;;hy                ; readability of scheme w/ speed of python
       ;;idris             ; a language you can depend on
       (json +lsp)            ; At least it ain't XML
       ;;(java +meghanada) ; the poster child for carpal tunnel syndrome
       (javascript +lsp)        ; all(hope(abandon(ye(who(enter(here))))))
       ;;julia             ; a better, faster MATLAB
       ;;kotlin            ; a better, slicker Java(Script)
       (latex +lsp)            ; writing papers in Emacs has never been so fun
       ;;lean              ; for folks with too much to prove
       ledger            ; be audit you can be
       ;;lua               ; one-based indices? one-based indices
       markdown          ; writing docs for people to ignore
       ;;nim               ; python + lisp at the speed of c
       nix               ; I hereby declare "nix geht mehr!"
       ;;ocaml             ; an objective camel
       (org +roam2)              ; organize your plain life in plain text
       ;;php               ; perl's insecure younger brother
       ;;plantuml          ; diagrams for confusing people more
       ;;purescript        ; javascript, but functional
       (python +lsp)            ; beautiful is better than ugly
       ;;qt                ; the 'cutest' gui framework ever
       (racket +lsp)           ; a DSL for DSLs
       ;;raku              ; the artist formerly known as perl6
       rest              ; Emacs as a REST client
       ;;rst               ; ReST in peace
       ;;(ruby +lsp)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
       (rust +lsp)              ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
       ;;scala             ; java, but good
       ;;(scheme +guile)   ; a fully conniving family of lisps
       (sh +lsp)               ; she sells {ba,z,fi}sh shells on the C xor
       ;;sml
       ;;solidity          ; do you need a blockchain? No.
       ;;swift             ; who asked for emoji variables?
       ;;terra             ; Earth and Moon in alignment for performance.
       (web +lsp)              ; the tubes
       (yaml +lsp)             ; JSON, but readable
       ;;zig               ; C, but simpler

       :email
       ;;(mu4e +org +gmail)
       ;;notmuch
       ;;(wanderlust +gmail)

       :app
       ;;calendar
       ;;emms
       everywhere        ; *leave* Emacs!? You must be joking
       ;;irc               ; how neckbeards socialize
       ;;(rss +org)        ; emacs as an RSS reader
       ;;twitter           ; twitter client https://twitter.com/vnought

       :config
       literate
       (default +bindings +smartparens))

<<config-file-location>>
<<leader-key>>
#+end_src

** Change the literate DOOM config file location
#+begin_src elisp
(setq +literate-config-file (concat doom-private-dir "README.org"))
#+end_src

** Change DOOM's leader key from "SPC" to ","

Here's a rundown of these all-important leader keys:

- =doom-leader-key=: Global leader key for global functions that should work regardless of whatever major mode is active.
- =doom-leader-alt-key=: Same as =doom-leader-key=, but accessible from Evil's Insert and Emacs states.
- =doom-localleader-key=: Major-mode-specific leader key. Brings up lots of commands that are specific to the current major mode.
- =doom-localleader-alt-key=: Same as =doom-localleader-alt-key=, but accessible from Evil's Insert and Emacs states.

NOTE: For all of DOOM's bindings, you can just press the keys and pause, and the minibuffer will tell you what keys are available. So you can explore what options are available interactively!

In order to use =C-,= from terminal Emacs, you have to make your terminal (e.g., Alacritty) send a special sequence (such as the =CSI u= scheme) and also make Emacs understand that sequence.

#+name: leader-key
#+begin_src elisp
(setq doom-leader-key ","
      doom-leader-alt-key "C-,"
      doom-localleader-key ", m"
      doom-localleader-alt-key "C-, m")
#+end_src

* $DOOMDIR/packages.el

#+begin_src elisp :tangle packages.el
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

;; To install a package with Doom you must declare them here and run 'doom sync'
;; on the command line, then restart Emacs for the changes to take effect -- or
;; use 'M-x doom/reload'.

;; To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:
;(package! some-package)

;; To install a package directly from a remote git repo, you must specify a
;; `:recipe'. You'll find documentation on what `:recipe' accepts here:
;; https://github.com/raxod502/straight.el#the-recipe-format
;(package! another-package
;  :recipe (:host github :repo "username/repo"))

;; If the package you are trying to install does not contain a PACKAGENAME.el
;; file, or is located in a subdirectory of the repo, you'll need to specify
;; `:files' in the `:recipe':
;(package! this-package
;  :recipe (:host github :repo "username/repo"
;           :files ("some-file.el" "src/lisp/*.el")))

;; If you'd like to disable a package included with Doom, you can do so here
;; with the `:disable' property:
;(package! builtin-package :disable t)

;; You can override the recipe of a built in package without having to specify
;; all the properties for `:recipe'. These will inherit the rest of its recipe
;; from Doom or MELPA/ELPA/Emacsmirror:
;(package! builtin-package :recipe (:nonrecursive t))
;(package! builtin-package-2 :recipe (:repo "myfork/package"))

;; Specify a `:branch' to install a package from a particular branch or tag.
;; This is required for some packages whose default branch isn't 'master' (which
;; our package manager can't deal with; see raxod502/straight.el#279)
;(package! builtin-package :recipe (:branch "develop"))

;; Use `:pin' to specify a particular commit to install.
;(package! builtin-package :pin "1a2b3c4d5e")


;; Doom's packages are pinned to a specific commit and updated from release to
;; release. The `unpin!' macro allows you to unpin single packages...
;(unpin! pinned-package)
;; ...or multiple packages
;(unpin! pinned-package another-pinned-package)
;; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
;(unpin! t)
(package! hl-line+)
(package! vim-empty-lines-mode)
(package! git-gutter)
(package! auto-dim-other-buffers)
(package! kakapo-mode)
<<package-zenburn-theme>>
#+end_src

* $DOOMDIR/config.el

This is the final structured output of =$DOOMDIR/config.el=, which is a special file that DOOM recognizes. Because of the way it acts as the "main" configuration file, you can think of it as =init.el= in the traditional Emacs sense. DOOM has its own =init.el= but that is another matter.

Note that this file is pretty much **required** and acts as the base for all other configurations that are pulled in. And so we define it first here.

#+begin_src elisp :tangle config.el
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

<<doom-bug-workarounds>>

<<CSI-u-mode-support>>

<<name-and-email>>

<<theme>>

<<org>>

<<line-numbers>>

<<easy-esc>>

<<remap-s>>
<<remap-leader-h>>
<<remap-leader-n>>

<<navigation-buffer-intra>>
<<navigation-buffer-inter>>

<<window-management>>

<<tab-management>>

<<buffer-management>>

<<editing>>
<<code>>

<<colors>>
<<misc-ui>>

;; Here are some additional functions/macros that could help you configure Doom:
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package!' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;   this file. Emacs searches the `load-path' when you load packages with
;;   `require' or `use-package'.
;; - `map!' for binding new keys
;;
;; To get information about any of these functions/macros, move the cursor over
;; the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
;; This will open documentation for it, including demos of how they are used.
;;
;; You can also try 'gd' (or 'C-c c d') to jump to their definition and see how
;; they are implemented.
#+end_src

#+RESULTS:
: tab-new

* DOOM bug workarounds

Here are some workarounds for upstream bugs that have not yet been fixed.

#+name: doom-bug-workarounds
#+begin_src elisp
<<iedit-embark-conflict>>
#+end_src

** https://github.com/hlissner/doom-emacs/issues/5374 (Key-binding conflict between iedit and embark)
#+name: iedit-embark-conflict
#+begin_src elisp
(use-package! iedit
  :when (featurep! :completion vertico)
  :defer t
  :init
  ;; Fix conflict with embark.
  (setq iedit-toggle-key-default nil))
#+end_src

* Global key-bindings
** CSI u mode support
See https://emacs.stackexchange.com/questions/1020/problems-with-keybindings-when-using-terminal/13957#13957 for a discussion of ~CSI u~ mode. Basically for us it allows us to use =C-S-= bindings from terminal emacs. It also allows us to specify many special keys in an unambiguous manner, so that we can, e.g., make =C-i= be recognized as =C-i= in terminal emacs (and not simply as =TAB= as is the default behavior).

#+name: CSI-u-mode-support
#+begin_src elisp
; Enable `CSI u` support. See https://emacs.stackexchange.com/a/59225.
; xterm with the resource ?.VT100.modifyOtherKeys: 1
; GNU Emacs >=24.4 sets xterm in this mode and define
; some of the escape sequences but not all of them.
; xterm with the resource ?.VT100.modifyOtherKeys: 1
; GNU Emacs >=24.4 sets xterm in this mode and define
; some of the escape sequences but not all of them.
(defun character-apply-modifiers (c &rest modifiers)
  "Apply modifiers to the character C.
MODIFIERS must be a list of symbols amongst (meta control shift).
Return an event vector."
  (if (memq 'control modifiers) (setq c (if (or (and (<= ?@ c) (<= c ?_))
                                                (and (<= ?a c) (<= c ?z)))
                                            (logand c ?\x1f)
                                          (logior (lsh 1 26) c))))
  (if (memq 'meta modifiers) (setq c (logior (lsh 1 27) c)))
  (if (memq 'shift modifiers) (setq c (logior (lsh 1 25) c)))
  (vector c))
(defun l/eval-after-load-xterm ()
  (interactive)
  (when (and (boundp 'xterm-extra-capabilities) (boundp 'xterm-function-map))
    (let ((c 32) (uppercase 65))
      ; Create bindings for all ASCII codepoints from 32 (SPACE) to 126 (~).
      ; That is, make Emacs understand what these `CSI u' sequences mean.
      (while (<= c 126)
        (mapc (lambda (x)
                (define-key xterm-function-map (format (car x) c)
                  (apply 'character-apply-modifiers c (cdr x))))
              '(("\e\[%d;3u" meta)
                ("\e\[%d;5u" control)
                ("\e\[%d;6u" control shift)
                ("\e\[%d;7u" control meta)
                ("\e\[%d;8u" control meta shift)))
        (setq c (1+ c)))
      ; Interpret the C-S-<letter> sequences encoded as `CSI u' sequences,
      ; (e.g., "\e\[76;6u" (C-S-L) as C-S-l). This is because in Alacritty we
      ; always use the uppercase ASCII letter for the codepoint between the `['
      ; and `;' delimiters of the sequence. This use of 6u instead of 5u
      ; somewhat deviates from the example for "A" vs "a" as described in
      ; http://www.leonerd.org.uk/hacks/fixterms/, because there they recommend
      ; "\e\[65;5u" (note the 5u instead of the 6u) to encode C-S-A. The reason
      ; we use 6u instead of the recommended 5u is because for some reason we
      ; cannot get 5u to work with tmux. That is, if we pass in "\e\[76;5u" from
      ; Alacritty to tmux, tmux encodes it as C-l instead of C-S-l. So instead
      ; we feed in the 6u variant from Alacritty, which tmux does recognize as
      ; C-S-l. And then we tell tmux to convert all such C-S- sequences back
      ; into a `CSI u' sequence, again using the 6u variant for Emacs to
      ; consume. We could probably use the 5u variant from within Emacs but
      ; using the 6u variant keeps all settings consistent across alacritty,
      ; tmux, and emacs.
      ;
      ; Anyway, now in terminal emacs we can distinguish between C-S-l and C-l.
      ;
      ; The (+ 32 uppercase) expression shifts the uppercase codepoint up by 32,
      ; making it lowercase for Emacs.
      ;
      ; See https://emacs.stackexchange.com/a/59225 for the idea. Note that this
      ; code does not match the answer there because it also depends on how you
      ; set up your Alacritty bindings; if you make Alacritty send lowercase
      ; ASCII letters (a-z) instead of uppercase ones (A-Z) then this hack
      ; probably is not necessary.
      (while (<= uppercase 90)
        (mapc (lambda (x)
                (define-key xterm-function-map (format (car x) uppercase)
                  (apply 'character-apply-modifiers (+ 32 uppercase) (cdr x))))
              '(("\e\[%d;6u" control shift)
                ("\e\[%d;8u" control meta shift)))
        (setq uppercase (1+ uppercase)))

      ; Tab
      ;
      ; The conflicts with TAB and C-i are due to tmux, which has a regression
      ; that treats these keys the same, even if our terminal uses `CSI u' mode
      ; to disambiguate them. See https://github.com/tmux/tmux/issues/2705. If
      ; it did not have that regression we would be able to bind TAB and C-i
      ; freely without restrictions.
      ;
      ; We cannot read M-S-Tab (it gets read as C-M-i).
      ;(define-key xterm-function-map "\e\[9;4u"
      ;  (apply 'character-apply-modifiers 9 '(meta shift)))         ; M-S-TAB
      (define-key xterm-function-map "\e\[9;5u"
        (apply 'character-apply-modifiers 9 '(control)))            ; C-TAB
      (define-key xterm-function-map "\e\[9;6u"
        (apply 'character-apply-modifiers 9 '(control shift)))      ; C-S-TAB
      ; We cannot read C-M-Tab (it gets read as C-M-i).
      ;(define-key xterm-function-map "\e\[9;7u"
      ;  (apply 'character-apply-modifiers 9 '(control meta)))       ; C-M-TAB
      ; We cannot read C-M-S-Tab (it gets read as C-M-S-i).
      ;(define-key xterm-function-map "\e\[9;8u"
      ;  (apply 'character-apply-modifiers 9 '(control meta shift))) ; C-M-S-TAB

      ; Backspace (DEL)
      (define-key xterm-function-map "\e\[127;3u"
        (apply 'character-apply-modifiers 127 '(meta)))               ; M-DEL
      (define-key xterm-function-map "\e\[127;4u"
        (apply 'character-apply-modifiers 127 '(meta shift)))         ; M-S-DEL
      (define-key xterm-function-map "\e\[127;5u"
        (apply 'character-apply-modifiers 127 '(control)))            ; C-DEL
      (define-key xterm-function-map "\e\[127;6u"
        (apply 'character-apply-modifiers 127 '(control shift)))      ; C-S-DEL
      (define-key xterm-function-map "\e\[127;7u"
        (apply 'character-apply-modifiers 127 '(control meta)))       ; C-M-DEL
      (define-key xterm-function-map "\e\[127;8u"
        (apply 'character-apply-modifiers 127 '(control meta shift))) ; C-M-S-DEL

      ; Enter (RET)
      (define-key xterm-function-map "\e\[13;3u"
        (apply 'character-apply-modifiers 13 '(meta)))               ; M-RET
      (define-key xterm-function-map "\e\[13;4u"
        (apply 'character-apply-modifiers 13 '(meta shift)))         ; M-S-RET
      (define-key xterm-function-map "\e\[13;5u"
        (apply 'character-apply-modifiers 13 '(control)))            ; C-RET
      (define-key xterm-function-map "\e\[13;6u"
        (apply 'character-apply-modifiers 13 '(control shift)))      ; C-S-RET
      (define-key xterm-function-map "\e\[13;7u"
        (apply 'character-apply-modifiers 13 '(control meta)))       ; C-M-RET
      (define-key xterm-function-map "\e\[13;8u"
        (apply 'character-apply-modifiers 13 '(control meta shift)))))) ; C-M-S-RET

(eval-after-load "xterm" '(l/eval-after-load-xterm))
#+end_src

** Enter Evil normal state quickly (default: "ESC" key)

Make "kj" behave as ESC key.
#+name: easy-esc
#+begin_src elisp
(use-package! evil-escape
  :config
  (setq evil-escape-key-sequence "kj"))
#+end_src

#+RESULTS: easy-esc
: evil-substitute

** Override default DOOM bindings

*** Basic buffer navigation

**** Intra-buffer navigation

We remap Backspace and Space keys because they are by default aliases to =h= and =l= keys, respectively, making them redundant.

#+name: navigation-buffer-intra
#+begin_src elisp
(map! :m "SPC" (cmd!! #'l/scroll-jump 10)
      :mn "DEL" (cmd!! #'l/scroll-jump -10))
(defun l/scroll-jump (cnt)
  "Scroll by CNT lines."
  (interactive "p")
  (forward-line cnt)
  (evil-scroll-line-to-center nil))
#+end_src

**** Intra-buffer navigation

We remap H and L keys because they do almost-useless things (go to the top and bottom of the current window).

#+name: navigation-buffer-inter
#+begin_src elisp
(map! :m "H" #'previous-buffer
      :m "L" #'next-buffer)
#+end_src

*** Restore old "s" key behavior in Evil normal mode

Remap =s= back to =evil-substitute=, instead of =evil-snipe-s=. However, map =S= to evil-snipe-s because it can't hurt and we never use =S= in vanilla Vim anyway.
#+name: remap-s
#+begin_src elisp
(remove-hook 'doom-first-input-hook #'evil-snipe-mode)
(map! :n "S" #'evil-snipe-s)
#+end_src

*** Remap the "+help" function from ", h" to ", H"

#+name: remap-leader-h
#+begin_src elisp
(map! :leader :desc "help" "H" help-map)
#+end_src

*** Remap the "+notes" function from ", n" to ", N"

The "+notes" is a ~:prefix-map~ binding, which means that it creates a ~doom-leader-<description>-map~ keymap. In order to rebind this thing, we just need to refer to it by its map.

See https://github.com/hlissner/doom-emacs/issues/4569#issuecomment-777861333.

#+name: remap-leader-n
#+begin_src elisp
(map! :leader
      :desc "notes"
      "N" doom-leader-notes-map)
#+end_src

** Window management

#+name: window-management
#+begin_src elisp
<<window-splits>>
<<window-deletion>>
<<window-navigation>>
#+end_src

*** Splits (window creation)

Splitting windows happens so frequently that we put these bindings at the top level just after the leader key.

#+name: window-splits
#+begin_src elisp
(map! :leader
      :desc "split-h" "h" #'split-window-vertically
      :desc "split-v" "v" #'split-window-horizontally)
(map! :after org
      :map org-mode-map
      "|" nil)
(map! :after evil
      :map evil-normal-state-map
      "=" nil
      :map evil-motion-state-map
      "-" #'enlarge-window
      "_" #'shrink-window
      "+" #'balance-windows
      "\\" #'enlarge-window-horizontally
      "|" #'shrink-window-horizontally)
#+end_src

**** Dead code

We used to use this to always split and rebalance. However in practice the need to rebalance does not arise that frequently because by default the initial split will be balanced.

#+begin_src elisp
(defun l/split-vertically ()
  "Split window verically."
  (interactive)
  (split-window-vertically)
  (balance-windows))
(defun l/split-horizontally ()
  "Split window horizontally."
  (interactive)
  (split-window-horizontally)
  (balance-windows))
#+end_src

*** Deletion

If there are multiple windows, close the current window. Otherwise close the current tab if there are mulitple tabs. Otherwise, try to exit emacs.

We take care to tread around so-called "auxiliary" buffers, which are auto-generated buffers from various emacs modes/packages.

#+name: window-deletion
#+begin_src elisp
(map! :leader
      :desc "quit/session" "Q" doom-leader-quit/session-map
      :desc "l/quit-buffer" "q" #'l/quit-buffer)
(defun l/quit-buffer ()
  "Tries to escape the current buffer by closing it (or moving to a
non-auxiliary buffer if possible). Calls `l/gc-views' to handle any sort of
window management issues."
  (interactive)
  (let*
    (
      (original-bufname (buffer-name))
      (aux-buffer-rgx "^ *\*.+\*$")
      (is-aux-buffer (l/buffer-looks-like original-bufname '("^ *\*.+\*$")))
      (buffers (mapcar 'buffer-name (buffer-list)))
      (primary-buffers-count
        (length
          (seq-filter
            '(lambda (bufname) (not (string-match "^ *\*.+\*$" bufname)))
            buffers)))
      (primary-buffer-exists (> primary-buffers-count 0))
    )

    ; If we're on a magit-controlled buffer, do what magit expects and simulate
    ; pressing C-c C-c (with-editor-finish).
    (catch 'my-catch
      (progn
        (if (bound-and-true-p with-editor-mode)
          (if (buffer-modified-p)
            ; If there are any unsaved changes, either discard those changes or do
            ; nothing.
            (if (y-or-n-p "l/quit-buffer: Invoke (with-editor-cancel) to cancel the editing of this buffer?")
              (with-editor-cancel t)
              ; Use catch/throw to stop execution.
              (throw 'my-catch (message "l/quit-buffer: Aborting (doing nothing).")))
            (with-editor-finish t)))
        ; Close the current view (or exit the editor entirely), but only if we
        ; originally tried to close a non-"auxiliary" buffer. An "auxiliary"
        ; buffer is any buffer that is created in support of another major
        ; buffer. For example, if we open buffer "A", but then run `M-x
        ; describe-function' so that we're on a "*Help*" buffer, do NOT close
        ; the view (and exit emacs). In other words, such "auxiliary" buffers,
        ; when we want to quit from them, we merely want to just switch over to
        ; a primary (non-auxiliary) buffer.
        ;
        ; If we *only* have auxiliary buffers, then of course just quit.
        (if (and is-aux-buffer primary-buffer-exists)
          ; Cycle through previous buffers until we hit a primary
          ; (non-auxiliary) buffer.
          (progn
            (catch 'buffer-cycle-detected
              (while
                (string-match "^ *\*.+\*$" (buffer-name))
                ; Break loop if somehow our aux-buffer-rgx failed to account for all
                ; hidden/aux buffers and we are just looping over and over among the
                ; same list of actual auxiliary buffers.
                (if (string= original-bufname (buffer-name))
                  (throw 'buffer-cycle-detected
                    (message "l/quit-buffer: Buffer cycle detected among auxiliary buffers; invoking `l/gc-views'."))
                  (previous-buffer))))
              ; If we've broken the loop (due to a cycle), run (l/gc-views) as
              ; it is better than doing nothing.
              (l/gc-views))
          (l/gc-views))))))

; Either close the current window, or if only one windw, use the ":q" Evil
; command; this simulates the ":q" behavior of Vim when used with tabs to
; garbage-collect the current "view".
(defun l/gc-views ()
  "Vimlike ':q' behavior: close current window if there are split windows;
otherwise, close current tab."
  (interactive)
  (let
    ( (one-tab (= 1 (length (tab-bar-tabs))))
      (one-window (one-window-p)))
    (cond
      ; If current tab has split windows in it, close the current live
      ; window.
      ((not one-window) (delete-window) nil)
      ; If there are multiple tabs, close the current one.
      ((not one-tab) (tab-bar-close-tab) nil)
      ; If there is only one tab, just try to quit (calling tab-bar-close-tab
      ; will not work, because if fails if there is only one tab).
      (one-tab
        (progn
          ; When closing the last frame of a graphic client, close everything we
          ; can. This is to catch graphical emacsclients that do not clean up
          ; after themselves.
          (if (display-graphic-p)
            (progn
              ; Minibuffers can create their own frames --- but they can linger
              ; around as an invisible frame even after they are deleted. Delete all
              ; other frames whenever we exit from a single visible daemon frame,
              ; because there is no point in keeping them around. If anything they
              ; can hinder detection of "is there a visible frame?" logic from the
              ; shell.
              (delete-other-frames)
              ; While we're at it, also close all buffers, because it's annoying to
              ; have things like Helm minibuffers and the like sitting around.
              (mapc
                'kill-buffer
                (seq-filter
                  (lambda (bufname)
                    (not (l/buffer-looks-like bufname
                      '(
                      ; Do not delete buffers that may be open which are for git
                      ; rebasing and committing. This is in case these buffers
                      ; are open in other clients which may still be working on
                      ; these buffers.
                      "^COMMIT_EDITMSG"
                      "^git-rebase-todo"
                      ; This catches buffers like 'addp-hunk-edit.diff' which is
                      ; used during surgical edits of what to stage ('e' option
                      ; to the 'git add -p' command).
                      ".*hunk-edit.diff"
                      ; Don't delete system buffers buffers.
                      "^\*Messages\*"))))
                  (mapcar 'buffer-name (buffer-list))))))
          (evil-quit)) nil))))

(defun l/buffer-looks-like (bufname regexes)
  "Return t if the buffer name looks like any of the given regexes."
  (interactive)
  (eval (cons 'or (mapcar
    (lambda (rgx) (string-match rgx bufname)) regexes))))
#+end_src

#+RESULTS: window-deletion
: l/buffer-looks-like

*** Navigation

Make =C-{j,k}= cycle through windows, and =C-S-{j,k}=.

#+name: window-navigation
#+begin_src elisp
(map! :after evil-org
      :map evil-org-mode-map
      ;; The org lang module (doom's module) has some arcane bindings which we
      ;; have to undo by pulling some teeth out. This includes undoing the
      ;; CSdown and CSup bindings which silently map to C-S-j and C-S-k,
      ;; respectively.
      :ni "C-S-k" nil
      :ni "C-S-j" nil)
(map! :imnv "C-j" (cmd!! #'other-window 1)
      :imnv "C-k" (cmd!! #'other-window -1)
      :imnv "C-S-j" #'window-swap-states
      :imnv "C-S-k" #'l/swap-window-states)

(defun l/swap-window-states () (interactive)
  (other-window -1)
  (window-swap-states)
  (other-window -1))
#+end_src

#+RESULTS: window-navigation

** Tabs

#+name: tab-management
#+begin_src elisp
<<tab-ui>>
<<tab-navigation>>
<<tab-creation>>
#+end_src

*** UI
#+name: tab-ui
#+begin_src elisp
(setq tab-bar-show t
      tab-bar-new-button-show nil
      tab-bar-close-button-show nil
      tab-bar-separator (propertize " " 'font-lock-face '(:background "color-16"))
      tab-bar-tab-name-function #'l/get-tab-name)

; Based on `tab-bar-tab-name-current-with-count', with some tweaks.
(defun l/get-tab-name ()
  "Generate tab name from the buffer of the selected window.
Also add the number of windows in the window configuration."
  (interactive)
  (let ((count (length (window-list-1 nil 'nomini)))
        (name (window-buffer (minibuffer-selected-window))))
    (if (> count 1)
        (format " [%d] %s " (- count 1) name)
        (format " %s " name))))
#+end_src

*** Creation

We don't have any code for deleting a tab because we only delete windows instead (and only delete the tab when the tab has only one window in it). This is so that we don't accidentally close a tab with a bunch of window splits, which can be laborious to reconstruct.

#+name: tab-creation
#+begin_src elisp
(map! :leader :desc "tab-new" "n" #'tab-new)
#+end_src

*** Navigation
#+name: tab-navigation
#+begin_src elisp
(map! :mi "C-l" #'tab-next
      :mi "C-h" #'tab-previous
      :mi "C-S-l" (cmd!! #'tab-bar-move-tab 1)
      :mi "C-S-h" (cmd!! #'tab-bar-move-tab -1))
#+end_src
** Buffer management

#+name: buffer-management
#+begin_src elisp
<<save-buffer>>
<<kill-buffer>>
#+end_src

*** Map ", w" to "save buffer"

#+name: save-buffer
#+begin_src elisp
(map! :leader :desc "window" "W" evil-window-map)
(map! :leader :desc "save-buffer" "w" #'save-buffer)
#+end_src

*** Kill buffers

#+name: kill-buffer
#+begin_src elisp
(map! :leader :desc "kill-buffer" "d" #'l/kill-this-buffer)
(map! :leader :desc "kill-buffer!" "D" #'l/kill-this-buffer!)
(defun l/kill-this-buffer ()
  "Kill current buffer."
  (interactive)
  (if (bound-and-true-p with-editor-mode)
    (with-editor-cancel t)
    (kill-this-buffer)))

(defun l/kill-this-buffer! ()
  "Kill current buffer even if it is modified."
  (interactive)
  (set-buffer-modified-p nil)
  (l/kill-this-buffer))
#+end_src

* Editing

#+name: editing
#+begin_src elisp
(map! :mi "C-o" #'l/insert-newline-below
      :mi "C-S-o" #'l/insert-newline-above)

(defun l/insert-newline-below ()
  (interactive)
  (forward-line 1)
  (beginning-of-line)
  (insert "\n")
  (forward-line -1))
(defun l/insert-newline-above ()
  (interactive)
  (beginning-of-line)
  (insert "\n")
  (forward-line -1))
#+end_src

* Code

#+name: code
#+begin_src elisp
(map! :after flycheck
      :leader :desc "flycheck" "F" flycheck-command-map)
(map! :after flycheck
      :map flycheck-command-map
      "n" #'l/flycheck-next-error
      "N" #'l/flycheck-prev-error)

(defun l/flycheck-next-error ()
  (interactive)
  (flycheck-next-error)
  (evil-scroll-line-to-center nil))
(defun l/flycheck-prev-error ()
  (interactive)
  (flycheck-previous-error)
  (evil-scroll-line-to-center nil))
#+end_src

* Colors

First install the zenburn-theme package, then load it by setting =doom-theme= to it.

#+name: package-zenburn-theme
#+begin_src elisp
(package! zenburn-theme)
#+end_src

#+name: theme
#+begin_src elisp
(setq doom-theme 'zenburn)
#+end_src

#+name: colors
#+begin_src elisp
(set-face-attribute 'tab-bar nil :background "color-16")
(set-face-attribute 'tab-bar-tab nil :weight 'bold :box nil :background "color-51")
(set-face-attribute 'tab-bar-tab-inactive nil :weight 'bold :box nil :foreground "color-16" :background "color-38")
(eval-after-load 'diff-mode
  '(progn
     ; Fix ugly colors for diffs. Prevalent because of git comit message buffers
     ; like COMMIT_EDITMSG.
     ; (set-face-attribute 'font-lock-comment-face nil :foreground "#9fc59f")
     ; (use-package git-commit
     ; :config (set-face-attribute 'git-commit-summary nil :foreground "cyan1"))
     (set-face-attribute 'diff-added       nil :foreground "green" :background "dark green")
     (set-face-attribute 'diff-removed     nil :foreground "red" :background "dark red")
     (set-face-attribute 'diff-context     nil :foreground "#ffffff")
     (set-face-attribute 'diff-header      nil :foreground "yellow" :background "#3f3f3f" :weight 'bold)
     (set-face-attribute 'diff-file-header nil :foreground "yellow" :background "#3f3f3f" :weight 'bold)
     (set-face-attribute 'diff-hunk-header nil :foreground "cyan"   :background "#3f3f3f")
     (set-face-attribute 'git-commit-keyword nil :foreground "#dcdccc" :background "#3f3f3f")))
#+end_src

* Org mode
#+name: org
#+begin_src elisp
;(after! (evil-org kakapo-mode)
;  (map! (:map (org-mode-map evil-org-mode-map)
;           :i [return] #'kakapo-ret-and-indent
;           :i "RET" #'kakapo-ret-and-indent)))

<<org-misc>>
#+end_src

** Misc

If you use "org" and don't want your org files in the default location below, change org-directory. It must be set before org loads!
#+name: org-misc
#+begin_src elisp
(setq org-directory "~/lo/note/")
#+end_src

* Misc settings

** Personal information

Some functionality uses this to identify you, e.g. GPG configuration, email clients, file templates and snippets.
#+name: name-and-email
#+begin_src elisp
(setq user-full-name "Linus Arver"
      user-mail-address "linusarver@gmail.com")
#+end_src

This determines the style of line numbers in effect. If set to "nil", line numbers are disabled. For relative line numbers, set this to "relative".
#+name: line-numbers
#+begin_src elisp
(setq display-line-numbers-type nil)
#+end_src

** Dead code

Before we started using Doom Emacs, we used to rely heavily on kakapo-mode to always insert either a tab or space character with the =TAB= key. However nowadays most languages have automated formatters that takes the guesswork around tabs/spaces out of the way. We could still enable kakapo-mode for some of the simpler modes that do not have a formatter, but for now we don't bother.

#+name: kakapo
#+begin_src elisp
(use-package! kakapo-mode
  :config
  (add-hook 'text-mode-hook #'kakapo-mode)
  (add-hook 'org-mode-hook #'kakapo-mode)
  (add-hook 'prog-mode-hook #'kakapo-mode))

(after! kakapo-mode
  (kakapo-mode))
#+end_src

** UI

#+name: misc-ui
#+begin_src elisp
;; Enable soft word-wrap almost everywhere (including elisp).
(+global-word-wrap-mode +1)

; Enable only left-side fringe.
(set-fringe-mode '(10 . 0))

; Disable hl-line mode, because it is extremely slow. We want to use hl-line+
; mode instead, which is much faster because it only highlights the line when
; idle.
(remove-hook 'doom-first-buffer-hook #'global-hl-line-mode)

(use-package! hl-line+
  :config
  (set-face-attribute 'hl-line nil :background "grey32")
  ; Highlight the current cursor line; set overlay to a high number to override
  ; other properties (e.g., mmm-default-submode-face).
  (setq hl-line-overlay-priority (/ most-positive-fixnum (expt 2 55)))
  ; Only highlight when idle.
  (toggle-hl-line-when-idle)
  (setq global-hl-line-mode nil)
  (hl-line-when-idle-interval 0.5))

(use-package! vim-empty-lines-mode
  :config
  (add-hook 'org-mode-hook 'vim-empty-lines-mode)
  (add-hook 'prog-mode-hook 'vim-empty-lines-mode)
  (add-hook 'text-mode-hook 'vim-empty-lines-mode)
  (set-face-attribute 'vim-empty-lines-face nil :weight 'bold))

; Modeline colors.
(set-face-attribute
 'mode-line nil
 :background "color-235"
 :foreground "color-231")
(set-face-attribute
 'mode-line-inactive nil
 :weight 'bold
 :background "color-16"
 :foreground "color-245")

; Dim buffers in inactive windows to make the current one "pop".
(use-package! auto-dim-other-buffers
 :config
 (auto-dim-other-buffers-mode)
 (set-face-attribute 'auto-dim-other-buffers-face nil :foreground "color-250" :background "color-234"))

; Always enable the tab bar, even if there is just one buffer showing (such as
; when we open a single buffer).
(tab-bar-mode)

; Use bright visuals for coloring regions and interactive search hits.
(set-face-attribute 'lazy-highlight nil :foreground "pink" :background "dark red" :weight 'normal)
(set-face-attribute 'isearch nil :foreground "dark red" :background "pink" :weight 'bold)
(set-face-attribute 'region nil :foreground "dark red" :background "pink" :weight 'bold)

(map! :after (git-gutter magit)
      :map doom-leader-git-map
      ; BUG: For some reason the "hunk" description does not show up in which-key.
      (:prefix-map ("h" . "hunk")
      "n" #'l/git-gutter:next-hunk
      "N" #'l/git-gutter:prev-hunk
      "r" #'git-gutter:revert-hunk
      ; "s" to mean "show hunk"
      "s" #'git-gutter:popup-hunk))

(defun l/git-gutter:next-hunk ()
  (interactive)
  (git-gutter:next-hunk 1)
  (evil-scroll-line-to-center nil))
(defun l/git-gutter:prev-hunk ()
  (interactive)
  (git-gutter:previous-hunk 1)
  (evil-scroll-line-to-center nil))

(use-package! git-gutter
  :after (hl-line+)
  :config
  ; Git diff +/- marks.
  (global-git-gutter-mode +1)
  ; Update git-gutter every time we lose/regain focus of the current window.
  ; This is to catch cases where we are SSH-ed in to a machine and are running
  ; emacs in terminal mode, which doesn't get the same "frame" focus signals as
  ; above because there is literally no frame.
  (defun l/git-gutter-refresh (orig-fun &rest args)
    (prog1
        (apply orig-fun args)
      (git-gutter:update-all-windows)))
  (advice-add 'select-window :around #'l/git-gutter-refresh)
  ; Make git-gutter refresh based on a timer (abuse the fact that
  ; hl-line-highlight-now is called whenever we're idle).
  (advice-add 'hl-line-highlight-now :around #'l/git-gutter-refresh)
  ; Update git-gutter every time we lose/regain focus to the frame. See
  ; https://emacs.stackexchange.com/a/60971/13006.
  (add-function :after after-focus-change-function (lambda () (unless (frame-focus-state) (git-gutter:update-all-windows))))
  (set-face-foreground 'git-gutter:modified "#d0d")
  (set-face-foreground 'git-gutter:added "#0d0")
  (set-face-foreground 'git-gutter:deleted "#d00")
  (setq git-gutter:modified-sign " ")
  (setq git-gutter:added-sign " ")
  (setq git-gutter:deleted-sign " "))
#+end_src

#+RESULTS: misc-ui
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (24929 19095 431973 760000) :init (24929 19095 431962 257000) :config (24929 19095 431943 173000) :config-secs (0 0 5902 333000) :init-secs (0 0 5934 774000) :use-package-secs (0 0 5985 204000)))

* Reference

#  LocalWords:  iedit ESC kj LocalWords DOOM's SPC Evil's minibuffer
